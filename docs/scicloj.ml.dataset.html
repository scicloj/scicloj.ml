<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>scicloj.ml.dataset documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scicloj</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ml</span></div></div></li><li class="depth-3 branch"><a href="scicloj.ml.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch current"><a href="scicloj.ml.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-3 branch"><a href="scicloj.ml.metamorph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>metamorph</span></div></a></li><li class="depth-3"><a href="scicloj.ml.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="scicloj.ml.dataset.html#var--.3Earray"><div class="inner"><span>-&gt;array</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-add-column"><div class="inner"><span>add-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-add-columns"><div class="inner"><span>add-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-add-or-replace-column"><div class="inner"><span>add-or-replace-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-add-or-replace-columns"><div class="inner"><span>add-or-replace-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-aggregate"><div class="inner"><span>aggregate</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-aggregate-columns"><div class="inner"><span>aggregate-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-anti-join"><div class="inner"><span>anti-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-append"><div class="inner"><span>append</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-as-regular-dataset"><div class="inner"><span>as-regular-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-asof-join"><div class="inner"><span>asof-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-bind"><div class="inner"><span>bind</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-boolean"><div class="inner"><span>boolean</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-by-rank"><div class="inner"><span>by-rank</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-categorical"><div class="inner"><span>categorical</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-categorical-.3Enumber"><div class="inner"><span>categorical-&gt;number</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-categorical-.3Eone-hot"><div class="inner"><span>categorical-&gt;one-hot</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-clone"><div class="inner"><span>clone</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column"><div class="inner"><span>column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column-count"><div class="inner"><span>column-count</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column-filter"><div class="inner"><span>column-filter</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column-names"><div class="inner"><span>column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-column-values-.3Ecategorical"><div class="inner"><span>column-values-&gt;categorical</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-columns"><div class="inner"><span>columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-concat"><div class="inner"><span>concat</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-concat-copying"><div class="inner"><span>concat-copying</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-convert-types"><div class="inner"><span>convert-types</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-create-categorical-map"><div class="inner"><span>create-categorical-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset"><div class="inner"><span>dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-.3Ecategorical-maps"><div class="inner"><span>dataset-&gt;categorical-maps</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-.3Ecategorical-xforms"><div class="inner"><span>dataset-&gt;categorical-xforms</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-.3Eone-hot-maps"><div class="inner"><span>dataset-&gt;one-hot-maps</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-.3Estr"><div class="inner"><span>dataset-&gt;str</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset-name"><div class="inner"><span>dataset-name</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-dataset.3F"><div class="inner"><span>dataset?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-datetime"><div class="inner"><span>datetime</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-drop"><div class="inner"><span>drop</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-drop-columns"><div class="inner"><span>drop-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-drop-missing"><div class="inner"><span>drop-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-drop-rows"><div class="inner"><span>drop-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-empty-ds.3F"><div class="inner"><span>empty-ds?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-feature"><div class="inner"><span>feature</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-feature-ecount"><div class="inner"><span>feature-ecount</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-fill-range-replace"><div class="inner"><span>fill-range-replace</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-first"><div class="inner"><span>first</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-fit-categorical-map"><div class="inner"><span>fit-categorical-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-fit-one-hot"><div class="inner"><span>fit-one-hot</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-fold-by"><div class="inner"><span>fold-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-full-join"><div class="inner"><span>full-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-group-by"><div class="inner"><span>group-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-grouped.3F"><div class="inner"><span>grouped?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-groups-.3Emap"><div class="inner"><span>groups-&gt;map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-groups-.3Eseq"><div class="inner"><span>groups-&gt;seq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-has-column.3F"><div class="inner"><span>has-column?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-head"><div class="inner"><span>head</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-column.3F"><div class="inner"><span>inference-column?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-target-column-names"><div class="inner"><span>inference-target-column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-target-ds"><div class="inner"><span>inference-target-ds</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-target-label-inverse-map"><div class="inner"><span>inference-target-label-inverse-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inference-target-label-map"><div class="inner"><span>inference-target-label-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-info"><div class="inner"><span>info</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-inner-join"><div class="inner"><span>inner-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-intersect"><div class="inner"><span>intersect</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-intersection"><div class="inner"><span>intersection</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-invert-categorical-map"><div class="inner"><span>invert-categorical-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-invert-one-hot-map"><div class="inner"><span>invert-one-hot-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-join-columns"><div class="inner"><span>join-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-k-fold-datasets"><div class="inner"><span>k-fold-datasets</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-labels"><div class="inner"><span>labels</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-last"><div class="inner"><span>last</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-left-join"><div class="inner"><span>left-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-map-columns"><div class="inner"><span>map-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-mark-as-group"><div class="inner"><span>mark-as-group</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-metadata-filter"><div class="inner"><span>metadata-filter</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-missing"><div class="inner"><span>missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-model-type"><div class="inner"><span>model-type</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-no-missing"><div class="inner"><span>no-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-num-inference-classes"><div class="inner"><span>num-inference-classes</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-numeric"><div class="inner"><span>numeric</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-of-datatype"><div class="inner"><span>of-datatype</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-order-by"><div class="inner"><span>order-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-pivot-.3Elonger"><div class="inner"><span>pivot-&gt;longer</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-pivot-.3Ewider"><div class="inner"><span>pivot-&gt;wider</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-prediction"><div class="inner"><span>prediction</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-print-dataset"><div class="inner"><span>print-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-probability-distribution"><div class="inner"><span>probability-distribution</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-probability-distributions-.3Elabel-column"><div class="inner"><span>probability-distributions-&gt;label-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-process-group-data"><div class="inner"><span>process-group-data</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-rand-nth"><div class="inner"><span>rand-nth</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-random"><div class="inner"><span>random</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-read-nippy"><div class="inner"><span>read-nippy</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-rename-columns"><div class="inner"><span>rename-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-reorder-columns"><div class="inner"><span>reorder-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-replace-missing"><div class="inner"><span>replace-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-reverse-map-categorical-xforms"><div class="inner"><span>reverse-map-categorical-xforms</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-right-join"><div class="inner"><span>right-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-row-count"><div class="inner"><span>row-count</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-rows"><div class="inner"><span>rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-select-columns"><div class="inner"><span>select-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-select-missing"><div class="inner"><span>select-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-select-rows"><div class="inner"><span>select-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-semi-join"><div class="inner"><span>semi-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-separate-column"><div class="inner"><span>separate-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-set-dataset-name"><div class="inner"><span>set-dataset-name</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-set-inference-target"><div class="inner"><span>set-inference-target</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-shape"><div class="inner"><span>shape</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-shuffle"><div class="inner"><span>shuffle</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-split"><div class="inner"><span>split</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-split-.3Eseq"><div class="inner"><span>split-&gt;seq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-string"><div class="inner"><span>string</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-tail"><div class="inner"><span>tail</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-target"><div class="inner"><span>target</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-train-test-split"><div class="inner"><span>train-test-split</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-transform-categorical-map"><div class="inner"><span>transform-categorical-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-transform-one-hot"><div class="inner"><span>transform-one-hot</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-ungroup"><div class="inner"><span>ungroup</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-unique-by"><div class="inner"><span>unique-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-unmark-group"><div class="inner"><span>unmark-group</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-unroll"><div class="inner"><span>unroll</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-update-columns"><div class="inner"><span>update-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-write.21"><div class="inner"><span>write!</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-write-csv.21"><div class="inner"><span>write-csv!</span></div></a></li><li class="depth-1"><a href="scicloj.ml.dataset.html#var-write-nippy.21"><div class="inner"><span>write-nippy!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">scicloj.ml.dataset</h1><div class="doc"><div class="markdown"><p>This namespace contains functions which operate on a dataset and mostly return a dataset.</p>
<p>The namespaces scicloj.ml.metamorph and scicloj.ml.dataset contain functions with the same name. But they operate on either a context map (ns metamorph) or on a dataset (ns dataset)</p>
<p>The functions in tis namespace are re-exported from:</p>
<ul>
  <li>tabecloth.api</li>
  <li>tech.v3.dataset.modelling</li>
  <li>tech.v3.dataset.column-filters</li>
</ul></div></div><div class="public anchor" id="var--.3Earray"><h3>-&gt;array</h3><div class="usage"><code>(-&gt;array ds colname)</code><code>(-&gt;array ds colname datatype)</code></div><div class="doc"><div class="markdown"><p>Convert numerical column(s) to java array</p></div></div></div><div class="public anchor" id="var-add-column"><h3>add-column</h3><div class="usage"><code>(add-column ds column-name column)</code><code>(add-column ds column-name column size-strategy)</code></div><div class="doc"><div class="markdown"><p>Add or update (modify) column under <code>column-name</code>.</p>
<p><code>column</code> can be sequence of values or generator function (which gets <code>ds</code> as input).</p></div></div></div><div class="public anchor" id="var-add-columns"><h3>add-columns</h3><div class="usage"><code>(add-columns ds columns-map)</code><code>(add-columns ds columns-map size-strategy)</code></div><div class="doc"><div class="markdown"><p>Add or updade (modify) columns defined in <code>columns-map</code> (mapping: name -&gt; column) </p></div></div></div><div class="public anchor" id="var-add-or-replace-column"><h3>add-or-replace-column</h3><div class="usage"><code>(add-or-replace-column ds column-name column)</code><code>(add-or-replace-column ds column-name column size-strategy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-or-replace-columns"><h3>add-or-replace-columns</h3><div class="usage"><code>(add-or-replace-columns ds columns-map)</code><code>(add-or-replace-columns ds columns-map size-strategy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-aggregate"><h3>aggregate</h3><div class="usage"><code>(aggregate ds aggregator)</code><code>(aggregate ds aggregator {:keys [default-column-name-prefix ungroup? parallel?], :or {default-column-name-prefix "summary", ungroup? true}, :as options})</code></div><div class="doc"><div class="markdown"><p>Aggregate dataset by providing:</p>
<ul>
  <li>aggregation function</li>
  <li>map with column names and functions</li>
  <li>sequence of aggregation functions</li>
</ul>
<p>Aggregation functions can return: - single value - seq of values - map of values with column names</p></div></div></div><div class="public anchor" id="var-aggregate-columns"><h3>aggregate-columns</h3><div class="usage"><code>(aggregate-columns ds columns-selector column-aggregators)</code><code>(aggregate-columns ds columns-selector column-aggregators options)</code></div><div class="doc"><div class="markdown"><p>Aggregates each column separately</p></div></div></div><div class="public anchor" id="var-anti-join"><h3>anti-join</h3><div class="usage"><code>(anti-join ds-left ds-right columns-selector)</code><code>(anti-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-append"><h3>append</h3><div class="usage"><code>(append ds &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-as-regular-dataset"><h3>as-regular-dataset</h3><div class="usage"><code>(as-regular-dataset ds)</code></div><div class="doc"><div class="markdown"><p>Remove grouping tag</p></div></div></div><div class="public anchor" id="var-asof-join"><h3>asof-join</h3><div class="usage"><code>(asof-join ds-left ds-right colname)</code><code>(asof-join ds-left ds-right colname options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind ds &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-boolean"><h3>boolean</h3><div class="usage"><code>(boolean dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the boolean columns.</p></div></div></div><div class="public anchor" id="var-by-rank"><h3>by-rank</h3><div class="usage"><code>(by-rank ds columns-selector rank-predicate)</code><code>(by-rank ds columns-selector rank-predicate {:keys [desc? ties], :or {desc? true, ties :dense}})</code></div><div class="doc"><div class="markdown"><p>Select rows using <code>rank</code> on a column, ties are resolved using <code>:dense</code> method.</p>
<p>See <a href="https://www.rdocumentation.org/packages/base/versions/3.6.1/topics/rank">R docs</a>. Rank uses 0 based indexing.</p>
<p>Possible <code>:ties</code> strategies: <code>:average</code>, <code>:first</code>, <code>:last</code>, <code>:random</code>, <code>:min</code>, <code>:max</code>, <code>:dense</code>. <code>:dense</code> is the same as in <code>data.table::frank</code> from R</p>
<p><code>:desc?</code> set to true (default) order descending before calculating rank</p></div></div></div><div class="public anchor" id="var-categorical"><h3>categorical</h3><div class="usage"><code>(categorical dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the categorical columns.</p></div></div></div><div class="public anchor" id="var-categorical-.3Enumber"><h3>categorical-&gt;number</h3><div class="usage"><code>(categorical-&gt;number dataset filter-fn-or-ds)</code><code>(categorical-&gt;number dataset filter-fn-or-ds table-args)</code><code>(categorical-&gt;number dataset filter-fn-or-ds table-args result-datatype)</code></div><div class="doc"><div class="markdown"><p>Convert columns into a discrete , numeric representation See tech.v3.dataset.categorical/fit-categorical-map.</p></div></div></div><div class="public anchor" id="var-categorical-.3Eone-hot"><h3>categorical-&gt;one-hot</h3><div class="usage"><code>(categorical-&gt;one-hot dataset filter-fn-or-ds)</code><code>(categorical-&gt;one-hot dataset filter-fn-or-ds table-args)</code><code>(categorical-&gt;one-hot dataset filter-fn-or-ds table-args result-datatype)</code></div><div class="doc"><div class="markdown"><p>Convert string columns to numeric columns. See tech.v3.dataset.categorical/fit-one-hot</p></div></div></div><div class="public anchor" id="var-clone"><h3>clone</h3><div class="usage"><code>(clone item)</code></div><div class="doc"><div class="markdown"><p>Clone an object. Can clone anything convertible to a reader.</p></div></div></div><div class="public anchor" id="var-column"><h3>column</h3><div class="usage"><code>(column dataset colname)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-count"><h3>column-count</h3><div class="usage"><code>(column-count dataset)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-filter"><h3>column-filter</h3><div class="usage"><code>(column-filter dataset filter-fn)</code></div><div class="doc"><div class="markdown"><p>Return a dataset with only the columns for which the filter function returns a truthy value.</p></div></div></div><div class="public anchor" id="var-column-names"><h3>column-names</h3><div class="usage"><code>(column-names ds)</code><code>(column-names ds columns-selector)</code><code>(column-names ds columns-selector meta-field)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-values-.3Ecategorical"><h3>column-values-&gt;categorical</h3><div class="usage"><code>(column-values-&gt;categorical dataset src-column)</code></div><div class="doc"><div class="markdown"><p>Given a column encoded via either string-&gt;number or one-hot, reverse map to the a sequence of the original string column values. In the case of one-hot mappings, src-column must be the original column name before the one-hot map</p></div></div></div><div class="public anchor" id="var-columns"><h3>columns</h3><div class="usage"><code>(columns ds)</code><code>(columns ds result-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-concat"><h3>concat</h3><div class="usage"><code>(concat dataset &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-concat-copying"><h3>concat-copying</h3><div class="usage"><code>(concat-copying dataset &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-convert-types"><h3>convert-types</h3><div class="usage"><code>(convert-types ds coltype-map-or-columns-selector)</code><code>(convert-types ds columns-selector new-types)</code></div><div class="doc"><div class="markdown"><p>Convert type of the column to the other type.</p></div></div></div><div class="public anchor" id="var-create-categorical-map"><h3>create-categorical-map</h3><div class="usage"><code>(create-categorical-map lookup-table src-colname result-datatype)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-dataset"><h3>dataset</h3><div class="usage"><code>(dataset)</code><code>(dataset data)</code><code>(dataset data {:keys [single-value-column-name column-names layout dataset-name], :or {single-value-column-name :$value, layout :as-columns}, :as options})</code></div><div class="doc"><div class="markdown"><p>Create <code>dataset</code>.</p>
<p>Dataset can be created from:</p>
<ul>
  <li>single value</li>
  <li>map of values and/or sequences</li>
  <li>sequence of maps</li>
  <li>sequence of columns</li>
  <li>file or url</li>
</ul></div></div></div><div class="public anchor" id="var-dataset-.3Ecategorical-maps"><h3>dataset-&gt;categorical-maps</h3><div class="usage"><code>(dataset-&gt;categorical-maps dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a map of column names to categorical label maps. This aids in inverting all of the label maps in a dataset. The source column name is src-column.</p></div></div></div><div class="public anchor" id="var-dataset-.3Ecategorical-xforms"><h3>dataset-&gt;categorical-xforms</h3><div class="usage"><code>(dataset-&gt;categorical-xforms ds)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a map of column-name-&gt;xform information.</p></div></div></div><div class="public anchor" id="var-dataset-.3Eone-hot-maps"><h3>dataset-&gt;one-hot-maps</h3><div class="usage"><code>(dataset-&gt;one-hot-maps dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a sequence of applied on-hot transformations.</p></div></div></div><div class="public anchor" id="var-dataset-.3Estr"><h3>dataset-&gt;str</h3><div class="usage"><code>(dataset-&gt;str ds options)</code><code>(dataset-&gt;str ds)</code></div><div class="doc"><div class="markdown"><p>Convert a dataset to a string. Prints a single line header and then calls dataset-data-&gt;str.</p>
<p>For options documentation see dataset-data-&gt;str.</p></div></div></div><div class="public anchor" id="var-dataset-name"><h3>dataset-name</h3><div class="usage"><code>(dataset-name dataset)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-dataset.3F"><h3>dataset?</h3><div class="usage"><code>(dataset? ds)</code></div><div class="doc"><div class="markdown"><p>Is <code>ds</code> a <code>dataset</code> type?</p></div></div></div><div class="public anchor" id="var-datetime"><h3>datetime</h3><div class="usage"><code>(datetime dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the datetime columns.</p></div></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><div class="usage"><code>(difference ds-left ds-right)</code><code>(difference ds-left ds-right options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-drop"><h3>drop</h3><div class="usage"><code>(drop ds columns-selector rows-selector)</code></div><div class="doc"><div class="markdown"><p>Drop columns and rows.</p></div></div></div><div class="public anchor" id="var-drop-columns"><h3>drop-columns</h3><div class="usage"><code>(drop-columns ds)</code><code>(drop-columns ds columns-selector)</code><code>(drop-columns ds columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Drop columns by (returns dataset):</p>
<ul>
  <li>name</li>
  <li>sequence of names</li>
  <li>map of names with new names (rename)</li>
  <li>function which filter names (via column metadata)</li>
</ul></div></div></div><div class="public anchor" id="var-drop-missing"><h3>drop-missing</h3><div class="usage"><code>(drop-missing ds)</code><code>(drop-missing ds columns-selector)</code></div><div class="doc"><div class="markdown"><p>Drop rows with missing values</p>
<p><code>columns-selector</code> selects columns to look at missing values</p></div></div></div><div class="public anchor" id="var-drop-rows"><h3>drop-rows</h3><div class="usage"><code>(drop-rows ds)</code><code>(drop-rows ds rows-selector)</code><code>(drop-rows ds rows-selector {:keys [select-keys pre result-type parallel?]})</code></div><div class="doc"><div class="markdown"><p>Drop rows using:</p>
<ul>
  <li>row id</li>
  <li>seq of row ids</li>
  <li>seq of true/false</li>
  <li>fn with predicate</li>
</ul></div></div></div><div class="public anchor" id="var-empty-ds.3F"><h3>empty-ds?</h3><div class="usage"><code>(empty-ds? ds)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-feature"><h3>feature</h3><div class="usage"><code>(feature dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset container only the columns which have not been marked as inference columns.</p></div></div></div><div class="public anchor" id="var-feature-ecount"><h3>feature-ecount</h3><div class="usage"><code>(feature-ecount dataset)</code></div><div class="doc"><div class="markdown"><p>Number of feature columns. Feature columns are columns that are not inference targets.</p></div></div></div><div class="public anchor" id="var-fill-range-replace"><h3>fill-range-replace</h3><div class="usage"><code>(fill-range-replace ds colname max-span)</code><code>(fill-range-replace ds colname max-span missing-strategy)</code><code>(fill-range-replace ds colname max-span missing-strategy missing-value)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-first"><h3>first</h3><div class="usage"><code>(first ds)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-fit-categorical-map"><h3>fit-categorical-map</h3><div class="usage"><code>(fit-categorical-map dataset colname &amp; [table-args res-dtype])</code></div><div class="doc"><div class="markdown"><p>Given a column, map it into an numeric space via a discrete map of values to integers. This fits the categorical transformation onto the column and returns the transformation. </p>
<p>If <code>table-args</code> is not given, the distinct column values will be mapped into 0..x without any specific order.</p>
<p>’table-args` allows to specify the precise mapping as a sequence of pairs of [val idx] or as a sorted seq of values.</p></div></div></div><div class="public anchor" id="var-fit-one-hot"><h3>fit-one-hot</h3><div class="usage"><code>(fit-one-hot dataset colname &amp; [table-args res-dtype])</code></div><div class="doc"><div class="markdown"><p>Fit a one hot transformation to a column. Returns a reusable transformation. Maps each unique value to a column with 1 every time the value appears in the original column and 0 otherwise.</p></div></div></div><div class="public anchor" id="var-fold-by"><h3>fold-by</h3><div class="usage"><code>(fold-by ds columns-selector)</code><code>(fold-by ds columns-selector folding-function)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-full-join"><h3>full-join</h3><div class="usage"><code>(full-join ds-left ds-right columns-selector)</code><code>(full-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-group-by"><h3>group-by</h3><div class="usage"><code>(group-by ds grouping-selector)</code><code>(group-by ds grouping-selector {:keys [select-keys result-type], :or {result-type :as-dataset, select-keys :all}, :as options})</code></div><div class="doc"><div class="markdown"><p>Group dataset by:</p>
<ul>
  <li>column name</li>
  <li>list of columns</li>
  <li>map of keys and row indexes</li>
  <li>function getting map of values</li>
</ul>
<p>Options are:</p>
<ul>
  <li>select-keys - when grouping is done by function, you can limit fields to a <code>select-keys</code> seq.</li>
  <li>result-type - return results as dataset (<code>:as-dataset</code>, default) or as map of datasets (<code>:as-map</code>) or as map of row indexes (<code>:as-indexes</code>) or as sequence of (sub)datasets</li>
  <li>other parameters which are passed to <code>dataset</code> fn</li>
</ul>
<p>When dataset is returned, meta contains <code>:grouped?</code> set to true. Columns in dataset:</p>
<ul>
  <li>name - group name</li>
  <li>group-id - id of the group (int)</li>
  <li>data - group as dataset</li>
</ul></div></div></div><div class="public anchor" id="var-grouped.3F"><h3>grouped?</h3><div class="usage"><code>(grouped? ds)</code></div><div class="doc"><div class="markdown"><p>Is <code>dataset</code> represents grouped dataset (result of <code>group-by</code>)?</p></div></div></div><div class="public anchor" id="var-groups-.3Emap"><h3>groups-&gt;map</h3><div class="usage"><code>(groups-&gt;map ds)</code></div><div class="doc"><div class="markdown"><p>Convert grouped dataset to the map of groups</p></div></div></div><div class="public anchor" id="var-groups-.3Eseq"><h3>groups-&gt;seq</h3><div class="usage"><code>(groups-&gt;seq ds)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-has-column.3F"><h3>has-column?</h3><div class="usage"><code>(has-column? dataset column-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-head"><h3>head</h3><div class="usage"><code>(head ds)</code><code>(head ds n)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-inference-column.3F"><h3>inference-column?</h3><div class="usage"><code>(inference-column? col)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-inference-target-column-names"><h3>inference-target-column-names</h3><div class="usage"><code>(inference-target-column-names ds)</code></div><div class="doc"><div class="markdown"><p>Return the names of the columns that are inference targets.</p></div></div></div><div class="public anchor" id="var-inference-target-ds"><h3>inference-target-ds</h3><div class="usage"><code>(inference-target-ds dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset return reverse-mapped inference target columns or nil in the case where there are no inference targets.</p></div></div></div><div class="public anchor" id="var-inference-target-label-inverse-map"><h3>inference-target-label-inverse-map</h3><div class="usage"><code>(inference-target-label-inverse-map dataset &amp; [label-columns])</code></div><div class="doc"><div class="markdown"><p>Given options generated during ETL operations and annotated with :label-columns sequence container 1 label column, generate a reverse map that maps from a dataset value back to the label that generated that value.</p></div></div></div><div class="public anchor" id="var-inference-target-label-map"><h3>inference-target-label-map</h3><div class="usage"><code>(inference-target-label-map dataset &amp; [label-columns])</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-info"><h3>info</h3><div class="usage"><code>(info ds)</code><code>(info ds result-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-inner-join"><h3>inner-join</h3><div class="usage"><code>(inner-join ds-left ds-right columns-selector)</code><code>(inner-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-intersect"><h3>intersect</h3><div class="usage"><code>(intersect ds-left ds-right)</code><code>(intersect ds-left ds-right options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><div class="usage"><code>(intersection lhs-ds rhs-ds)</code></div><div class="doc"><div class="markdown"><p>Return only columns for rhs for which an equivalently named column exists in lhs.</p></div></div></div><div class="public anchor" id="var-invert-categorical-map"><h3>invert-categorical-map</h3><div class="usage"><code>(invert-categorical-map dataset {:keys [src-column lookup-table]})</code></div><div class="doc"><div class="markdown"><p>Invert a categorical map returning the column to the original set of values.</p></div></div></div><div class="public anchor" id="var-invert-one-hot-map"><h3>invert-one-hot-map</h3><div class="usage"><code>(invert-one-hot-map dataset {:keys [one-hot-table src-column]})</code></div><div class="doc"><div class="markdown"><p>Invert a one-hot transformation removing the one-hot columns and adding back the original column.</p></div></div></div><div class="public anchor" id="var-join-columns"><h3>join-columns</h3><div class="usage"><code>(join-columns ds target-column columns-selector)</code><code>(join-columns ds target-column columns-selector {:keys [separator missing-subst drop-columns? result-type parallel?], :or {separator "-", drop-columns? true, result-type :string}})</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-k-fold-datasets"><h3>k-fold-datasets</h3><div class="usage"><code>(k-fold-datasets dataset k options)</code><code>(k-fold-datasets dataset k)</code></div><div class="doc"><div class="markdown"><p>Given 1 dataset, prepary K datasets using the k-fold algorithm. Randomize dataset defaults to true which will realize the entire dataset so use with care if you have large datasets.</p>
<p>Options:</p>
<ul>
  <li><code>:randomize-dataset?</code> - When true, shuffle the dataset. In that case ‘seed’ may be  provided. Defaults to true.</li>
  <li><code>:seed</code> - when <code>:randomize-dataset?</code> is true then this can either be an  implementation of java.util.Random or an integer seed which will be used to  construct java.util.Random.</li>
</ul></div></div></div><div class="public anchor" id="var-labels"><h3>labels</h3><div class="usage"><code>(labels dataset)</code></div><div class="doc"><div class="markdown"><p>Return the labels. The labels sequence is the reverse mapped inference column. This returns a single column of data or errors out.</p></div></div></div><div class="public anchor" id="var-last"><h3>last</h3><div class="usage"><code>(last ds)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-left-join"><h3>left-join</h3><div class="usage"><code>(left-join ds-left ds-right columns-selector)</code><code>(left-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-map-columns"><h3>map-columns</h3><div class="usage"><code>(map-columns ds column-name map-fn)</code><code>(map-columns ds column-name columns-selector map-fn)</code><code>(map-columns ds column-name new-type columns-selector map-fn)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-mark-as-group"><h3>mark-as-group</h3><div class="usage"><code>(mark-as-group ds)</code></div><div class="doc"><div class="markdown"><p>Add grouping tag</p></div></div></div><div class="public anchor" id="var-metadata-filter"><h3>metadata-filter</h3><div class="usage"><code>(metadata-filter dataset filter-fn)</code></div><div class="doc"><div class="markdown"><p>Return a dataset with only the columns for which, given the column metadata, the filter function returns a truthy value.</p></div></div></div><div class="public anchor" id="var-missing"><h3>missing</h3><div class="usage"><code>(missing dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset with only columns have have missing values</p></div></div></div><div class="public anchor" id="var-model-type"><h3>model-type</h3><div class="usage"><code>(model-type dataset &amp; [column-name-seq])</code></div><div class="doc"><div class="markdown"><p>Check the label column after dataset processing. Return either :regression :classification</p></div></div></div><div class="public anchor" id="var-no-missing"><h3>no-missing</h3><div class="usage"><code>(no-missing dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset with only columns that have no missing values.</p></div></div></div><div class="public anchor" id="var-num-inference-classes"><h3>num-inference-classes</h3><div class="usage"><code>(num-inference-classes dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset and correctly built options from pipeline operations, return the number of classes used for the label. Error if not classification dataset.</p></div></div></div><div class="public anchor" id="var-numeric"><h3>numeric</h3><div class="usage"><code>(numeric dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the numeric columns.</p></div></div></div><div class="public anchor" id="var-of-datatype"><h3>of-datatype</h3><div class="usage"><code>(of-datatype dataset datatype)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the columns of a specific datatype.</p></div></div></div><div class="public anchor" id="var-order-by"><h3>order-by</h3><div class="usage"><code>(order-by ds columns-or-fn)</code><code>(order-by ds columns-or-fn comparators)</code><code>(order-by ds columns-or-fn comparators {:keys [parallel?]})</code></div><div class="doc"><div class="markdown"><p>Order dataset by: - column name - columns (as sequence of names) - key-fn - sequence of columns / key-fn Additionally you can ask the order by: - :asc - :desc - custom comparator function</p></div></div></div><div class="public anchor" id="var-pivot-.3Elonger"><h3>pivot-&gt;longer</h3><div class="usage"><code>(pivot-&gt;longer ds)</code><code>(pivot-&gt;longer ds columns-selector)</code><code>(pivot-&gt;longer ds columns-selector {:keys [target-columns value-column-name splitter drop-missing? datatypes], :or {target-columns :$column, value-column-name :$value, drop-missing? true}})</code></div><div class="doc"><div class="markdown"><p><code>tidyr</code> pivot_longer api</p></div></div></div><div class="public anchor" id="var-pivot-.3Ewider"><h3>pivot-&gt;wider</h3><div class="usage"><code>(pivot-&gt;wider ds columns-selector value-columns)</code><code>(pivot-&gt;wider ds columns-selector value-columns {:keys [fold-fn concat-columns-with concat-value-with drop-missing?], :or {concat-columns-with "_", concat-value-with "-", drop-missing? true}})</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-prediction"><h3>prediction</h3><div class="usage"><code>(prediction dataset)</code></div><div class="doc"><div class="markdown"><p>Return the columns of the dataset marked as predictions.</p></div></div></div><div class="public anchor" id="var-print-dataset"><h3>print-dataset</h3><div class="usage"><code>(print-dataset ds)</code><code>(print-dataset ds options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-probability-distribution"><h3>probability-distribution</h3><div class="usage"><code>(probability-distribution dataset)</code></div><div class="doc"><div class="markdown"><p>Return the columns of the dataset that comprise the probability distribution after classification.</p></div></div></div><div class="public anchor" id="var-probability-distributions-.3Elabel-column"><h3>probability-distributions-&gt;label-column</h3><div class="usage"><code>(probability-distributions-&gt;label-column prob-ds dst-colname)</code></div><div class="doc"><div class="markdown"><p>Given a dataset that has columns in which the column names describe labels and the rows describe a probability distribution, create a label column by taking the max value in each row and assign column that row value.</p></div></div></div><div class="public anchor" id="var-process-group-data"><h3>process-group-data</h3><div class="usage"><code>(process-group-data ds f)</code><code>(process-group-data ds f parallel?)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-rand-nth"><h3>rand-nth</h3><div class="usage"><code>(rand-nth ds)</code><code>(rand-nth ds {:keys [seed]})</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-random"><h3>random</h3><div class="usage"><code>(random ds)</code><code>(random ds n)</code><code>(random ds n {:keys [repeat? seed], :or {repeat? true}})</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-read-nippy"><h3>read-nippy</h3><div class="usage"><code>(read-nippy filename)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-rename-columns"><h3>rename-columns</h3><div class="usage"><code>(rename-columns ds columns-selector columns-map-fn)</code><code>(rename-columns ds columns-mapping)</code></div><div class="doc"><div class="markdown"><p>Rename columns with provided old -&gt; new name map</p></div></div></div><div class="public anchor" id="var-reorder-columns"><h3>reorder-columns</h3><div class="usage"><code>(reorder-columns ds columns-selector &amp; columns-selectors)</code></div><div class="doc"><div class="markdown"><p>Reorder columns using column selector(s). When column names are incomplete, the missing will be attached at the end.</p></div></div></div><div class="public anchor" id="var-replace-missing"><h3>replace-missing</h3><div class="usage"><code>(replace-missing ds)</code><code>(replace-missing ds strategy)</code><code>(replace-missing ds columns-selector strategy)</code><code>(replace-missing ds columns-selector strategy value)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-reverse-map-categorical-xforms"><h3>reverse-map-categorical-xforms</h3><div class="usage"><code>(reverse-map-categorical-xforms dataset)</code></div><div class="doc"><div class="markdown"><p>Given a dataset where we have converted columns from a categorical representation to either a numeric reprsentation or a one-hot representation, reverse map back to the original dataset given the reverse mapping of label-&gt;number in the column’s metadata.</p></div></div></div><div class="public anchor" id="var-right-join"><h3>right-join</h3><div class="usage"><code>(right-join ds-left ds-right columns-selector)</code><code>(right-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-row-count"><h3>row-count</h3><div class="usage"><code>(row-count dataset-or-col)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-rows"><h3>rows</h3><div class="usage"><code>(rows ds)</code><code>(rows ds result-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select ds columns-selector rows-selector)</code></div><div class="doc"><div class="markdown"><p>Select columns and rows.</p></div></div></div><div class="public anchor" id="var-select-columns"><h3>select-columns</h3><div class="usage"><code>(select-columns ds)</code><code>(select-columns ds columns-selector)</code><code>(select-columns ds columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Select columns by (returns dataset):</p>
<ul>
  <li>name</li>
  <li>sequence of names</li>
  <li>map of names with new names (rename)</li>
  <li>function which filter names (via column metadata)</li>
</ul></div></div></div><div class="public anchor" id="var-select-missing"><h3>select-missing</h3><div class="usage"><code>(select-missing ds)</code><code>(select-missing ds columns-selector)</code></div><div class="doc"><div class="markdown"><p>Select rows with missing values</p>
<p><code>columns-selector</code> selects columns to look at missing values</p></div></div></div><div class="public anchor" id="var-select-rows"><h3>select-rows</h3><div class="usage"><code>(select-rows ds)</code><code>(select-rows ds rows-selector)</code><code>(select-rows ds rows-selector {:keys [select-keys pre result-type parallel?]})</code></div><div class="doc"><div class="markdown"><p>Select rows using:</p>
<ul>
  <li>row id</li>
  <li>seq of row ids</li>
  <li>seq of true/false</li>
  <li>fn with predicate</li>
</ul></div></div></div><div class="public anchor" id="var-semi-join"><h3>semi-join</h3><div class="usage"><code>(semi-join ds-left ds-right columns-selector)</code><code>(semi-join ds-left ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-separate-column"><h3>separate-column</h3><div class="usage"><code>(separate-column ds column separator)</code><code>(separate-column ds column target-columns separator)</code><code>(separate-column ds column target-columns separator {:keys [missing-subst drop-column? parallel?], :or {missing-subst ""}})</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-set-dataset-name"><h3>set-dataset-name</h3><div class="usage"><code>(set-dataset-name dataset ds-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-set-inference-target"><h3>set-inference-target</h3><div class="usage"><code>(set-inference-target dataset target-name-or-target-name-seq)</code></div><div class="doc"><div class="markdown"><p>Set the inference target on the column. This sets the :column-type member of the column metadata to :inference-target?.</p></div></div></div><div class="public anchor" id="var-shape"><h3>shape</h3><div class="usage"><code>(shape ds)</code></div><div class="doc"><div class="markdown"><p>Returns shape of the dataset [rows, cols]</p></div></div></div><div class="public anchor" id="var-shuffle"><h3>shuffle</h3><div class="usage"><code>(shuffle ds)</code><code>(shuffle ds {:keys [seed]})</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-split"><h3>split</h3><div class="usage"><code>(split ds)</code><code>(split ds split-type)</code><code>(split ds split-type {:keys [seed parallel? shuffle?], :or {shuffle? true}, :as opts})</code></div><div class="doc"><div class="markdown"><p>Split given dataset into 2 or more (holdout) splits</p>
<p>As the result two new columns are added:</p>
<ul>
  <li><code>:$split-name</code> - with subgroup name</li>
  <li><code>:$split-id</code> - fold id/repetition id</li>
</ul>
<p><code>split-type</code> can be one of the following:</p>
<ul>
  <li><code>:kfold</code> - k-fold strategy, <code>:k</code> defines number of folds (defaults to <code>5</code>), produces <code>k</code> splits</li>
  <li><code>:bootstrap</code> - <code>:ratio</code> defines ratio of observations put into result (defaults to <code>1.0</code>), produces <code>1</code> split</li>
  <li><code>:holdout</code> - split into two parts with given ratio (defaults to <code>2/3</code>), produces <code>1</code> split</li>
  <li><code>:loo</code> - leave one out, produces the same number of splits as number of observations</li>
</ul>
<p><code>:holdout</code> can accept also probabilites or ratios and can split to more than 2 subdatasets</p>
<p>Additionally you can provide:</p>
<ul>
  <li><code>:seed</code> - for random number generator</li>
  <li><code>:repeats</code> - repeat procedure <code>:repeats</code> times</li>
  <li><code>:partition-selector</code> - same as in <code>group-by</code> for stratified splitting to reflect dataset structure in splits.</li>
  <li><code>:split-names</code> names of subdatasets different than default, ie. <code>[:train :test :split-2 ...]</code></li>
  <li><code>:split-col-name</code> - a column where name of split is stored, either <code>:train</code> or <code>:test</code> values (default: <code>:$split-name</code>)</li>
  <li><code>:split-id-col-name</code> - a column where id of the train/test pair is stored (default: <code>:$split-id</code>)</li>
</ul>
<p>Rows are shuffled before splitting.</p>
<p>In case of grouped dataset each group is processed separately.</p>
<p>See <a href="https://www.mitpressjournals.org/doi/pdf/10.1162/EVCO_a_00069">more</a></p></div></div></div><div class="public anchor" id="var-split-.3Eseq"><h3>split-&gt;seq</h3><div class="usage"><code>(split-&gt;seq ds)</code><code>(split-&gt;seq ds split-type)</code><code>(split-&gt;seq ds split-type {:keys [split-col-name split-id-col-name], :or {split-col-name :$split-name, split-id-col-name :$split-id}, :as opts})</code></div><div class="doc"><div class="markdown"><p>Returns split as a sequence of train/test datasets or map of sequences (grouped dataset)</p></div></div></div><div class="public anchor" id="var-string"><h3>string</h3><div class="usage"><code>(string dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the string columns.</p></div></div></div><div class="public anchor" id="var-tail"><h3>tail</h3><div class="usage"><code>(tail ds)</code><code>(tail ds n)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-target"><h3>target</h3><div class="usage"><code>(target dataset)</code></div><div class="doc"><div class="markdown"><p>Return a dataset containing only the columns that have been marked as inference targets.</p></div></div></div><div class="public anchor" id="var-train-test-split"><h3>train-test-split</h3><div class="usage"><code>(train-test-split dataset {:keys [train-fraction], :or {train-fraction 0.7}, :as options})</code><code>(train-test-split dataset)</code></div><div class="doc"><div class="markdown"><p>Probabilistically split the dataset returning a map of <code>{:train-ds :test-ds}</code>.</p>
<p>Options:</p>
<ul>
  <li><code>:randomize-dataset?</code> - When true, shuffle the dataset. In that case ‘seed’ may be  provided. Defaults to true.</li>
  <li><code>:seed</code> - when <code>:randomize-dataset?</code> is true then this can either be an  implementation of java.util.Random or an integer seed which will be used to  construct java.util.Random.</li>
  <li><code>:train-fraction</code> - Fraction of the dataset to use as training set. Defaults to  0.7.</li>
</ul></div></div></div><div class="public anchor" id="var-transform-categorical-map"><h3>transform-categorical-map</h3><div class="usage"><code>(transform-categorical-map dataset fit-data)</code></div><div class="doc"><div class="markdown"><p>Apply a categorical mapping transformation fit with fit-categorical-map.</p></div></div></div><div class="public anchor" id="var-transform-one-hot"><h3>transform-one-hot</h3><div class="usage"><code>(transform-one-hot dataset one-hot-fit-data)</code></div><div class="doc"><div class="markdown"><p>Apply a one-hot transformation to a dataset</p></div></div></div><div class="public anchor" id="var-ungroup"><h3>ungroup</h3><div class="usage"><code>(ungroup ds)</code><code>(ungroup ds {:keys [order? add-group-as-column add-group-id-as-column separate? dataset-name parallel?], :or {separate? true}})</code></div><div class="doc"><div class="markdown"><p>Concat groups into dataset.</p>
<p>When <code>add-group-as-column</code> or <code>add-group-id-as-column</code> is set to <code>true</code> or name(s), columns with group name(s) or group id is added to the result.</p>
<p>Before joining the groups groups can be sorted by group name.</p></div></div></div><div class="public anchor" id="var-union"><h3>union</h3><div class="usage"><code>(union ds &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-unique-by"><h3>unique-by</h3><div class="usage"><code>(unique-by ds)</code><code>(unique-by ds columns-selector)</code><code>(unique-by ds columns-selector {:keys [strategy select-keys parallel?], :or {strategy :first}, :as options})</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-unmark-group"><h3>unmark-group</h3><div class="usage"><code>(unmark-group ds)</code></div><div class="doc"><div class="markdown"><p>Remove grouping tag</p></div></div></div><div class="public anchor" id="var-unroll"><h3>unroll</h3><div class="usage"><code>(unroll ds columns-selector)</code><code>(unroll ds columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-update-columns"><h3>update-columns</h3><div class="usage"><code>(update-columns ds columns-map)</code><code>(update-columns ds columns-selector update-functions)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-write.21"><h3>write!</h3><div class="usage"><code>(write! dataset output-path options)</code><code>(write! dataset output-path)</code></div><div class="doc"><div class="markdown"><p>Write a dataset out to a file. Supported forms are:</p>
<pre><code class="clojure">(ds/write! test-ds "test.csv")
(ds/write! test-ds "test.tsv")
(ds/write! test-ds "test.tsv.gz")
(ds/write! test-ds "test.nippy")
(ds/write! test-ds out-stream)
</code></pre>
<p>Options:</p>
<ul>
  <li><code>:max-chars-per-column</code> - csv,tsv specific, defaults to 65536 - values longer than this will  cause an exception during serialization.</li>
  <li><code>:max-num-columns</code> - csv,tsv specific, defaults to 8192 - If the dataset has more than this number of  columns an exception will be thrown during serialization.</li>
  <li><code>:quoted-columns</code> - csv specific - sequence of columns names that you would like to always have quoted.</li>
  <li><code>:file-type</code> - Manually specify the file type. This is usually inferred from the filename but if you  pass in an output stream then you will need to specify the file type.</li>
  <li><code>:headers?</code> - if csv headers are written, defaults to true.</li>
</ul></div></div></div><div class="public anchor" id="var-write-csv.21"><h3>write-csv!</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-write-nippy.21"><h3>write-nippy!</h3><div class="usage"><code>(write-nippy! ds filename)</code></div><div class="doc"><div class="markdown"></div></div></div></div></body></html>