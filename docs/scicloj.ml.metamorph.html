<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>scicloj.ml.metamorph documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scicloj</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ml</span></div></div></li><li class="depth-3 branch"><a href="scicloj.ml.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="scicloj.ml.dataset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dataset</span></div></a></li><li class="depth-3 branch current"><a href="scicloj.ml.metamorph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>metamorph</span></div></a></li><li class="depth-3"><a href="scicloj.ml.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="scicloj.ml.metamorph.html#var--.3Earray"><div class="inner"><span>-&gt;array</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-column"><div class="inner"><span>add-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-columns"><div class="inner"><span>add-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-or-replace-column"><div class="inner"><span>add-or-replace-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-or-replace-columns"><div class="inner"><span>add-or-replace-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-add-or-update-column"><div class="inner"><span>add-or-update-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-aggregate"><div class="inner"><span>aggregate</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-aggregate-columns"><div class="inner"><span>aggregate-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-anti-join"><div class="inner"><span>anti-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-append"><div class="inner"><span>append</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-append-columns"><div class="inner"><span>append-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-as-regular-dataset"><div class="inner"><span>as-regular-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-asof-join"><div class="inner"><span>asof-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-assoc-ds"><div class="inner"><span>assoc-ds</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-assoc-metadata"><div class="inner"><span>assoc-metadata</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bind"><div class="inner"><span>bind</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bow-.3Esomething-sparse"><div class="inner"><span>bow-&gt;something-sparse</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bow-.3Esparse-array"><div class="inner"><span>bow-&gt;sparse-array</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bow-.3ESparseArray"><div class="inner"><span>bow-&gt;SparseArray</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-bow-.3Etfidf"><div class="inner"><span>bow-&gt;tfidf</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-brief"><div class="inner"><span>brief</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-by-rank"><div class="inner"><span>by-rank</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-categorical-.3Enumber"><div class="inner"><span>categorical-&gt;number</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-categorical-.3Eone-hot"><div class="inner"><span>categorical-&gt;one-hot</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-clone"><div class="inner"><span>clone</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-cluster"><div class="inner"><span>cluster</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column"><div class="inner"><span>column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-.3Edataset"><div class="inner"><span>column-&gt;dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-cast"><div class="inner"><span>column-cast</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-count"><div class="inner"><span>column-count</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-labeled-mapseq"><div class="inner"><span>column-labeled-mapseq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-map"><div class="inner"><span>column-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-names"><div class="inner"><span>column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-column-values-.3Ecategorical"><div class="inner"><span>column-values-&gt;categorical</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-columns"><div class="inner"><span>columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-columns-with-missing-seq"><div class="inner"><span>columns-with-missing-seq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-columnwise-concat"><div class="inner"><span>columnwise-concat</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-concat"><div class="inner"><span>concat</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-concat-copying"><div class="inner"><span>concat-copying</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-concat-inplace"><div class="inner"><span>concat-inplace</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-convert-types"><div class="inner"><span>convert-types</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-count-vectorize"><div class="inner"><span>count-vectorize</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-data-.3Edataset"><div class="inner"><span>data-&gt;dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset-.3Ecategorical-xforms"><div class="inner"><span>dataset-&gt;categorical-xforms</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset-.3Edata"><div class="inner"><span>dataset-&gt;data</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset-.3Estr"><div class="inner"><span>dataset-&gt;str</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset-name"><div class="inner"><span>dataset-name</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-dataset.3F"><div class="inner"><span>dataset?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-descriptive-stats"><div class="inner"><span>descriptive-stats</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-drop"><div class="inner"><span>drop</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-drop-columns"><div class="inner"><span>drop-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-drop-missing"><div class="inner"><span>drop-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-drop-rows"><div class="inner"><span>drop-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-empty-ds.3F"><div class="inner"><span>empty-ds?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-ensure-array-backed"><div class="inner"><span>ensure-array-backed</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-feature-ecount"><div class="inner"><span>feature-ecount</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-fill-range-replace"><div class="inner"><span>fill-range-replace</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-filter"><div class="inner"><span>filter</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-filter-column"><div class="inner"><span>filter-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-filter-dataset"><div class="inner"><span>filter-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-first"><div class="inner"><span>first</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-fold-by"><div class="inner"><span>fold-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-full-join"><div class="inner"><span>full-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-group-by"><div class="inner"><span>group-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-group-by-.3Eindexes"><div class="inner"><span>group-by-&gt;indexes</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-group-by-column"><div class="inner"><span>group-by-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-group-by-column-.3Eindexes"><div class="inner"><span>group-by-column-&gt;indexes</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-grouped.3F"><div class="inner"><span>grouped?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-groups-.3Emap"><div class="inner"><span>groups-&gt;map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-groups-.3Eseq"><div class="inner"><span>groups-&gt;seq</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-has-column.3F"><div class="inner"><span>has-column?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-head"><div class="inner"><span>head</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-column.3F"><div class="inner"><span>inference-column?</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-target-column-names"><div class="inner"><span>inference-target-column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-target-ds"><div class="inner"><span>inference-target-ds</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-target-label-inverse-map"><div class="inner"><span>inference-target-label-inverse-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inference-target-label-map"><div class="inner"><span>inference-target-label-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-info"><div class="inner"><span>info</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-inner-join"><div class="inner"><span>inner-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-intersect"><div class="inner"><span>intersect</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-join-columns"><div class="inner"><span>join-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-labels"><div class="inner"><span>labels</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-last"><div class="inner"><span>last</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-left-join"><div class="inner"><span>left-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-map-columns"><div class="inner"><span>map-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-mapseq-reader"><div class="inner"><span>mapseq-reader</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-mark-as-group"><div class="inner"><span>mark-as-group</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-min-max-scale"><div class="inner"><span>min-max-scale</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-min-n-by-column"><div class="inner"><span>min-n-by-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-missing"><div class="inner"><span>missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-model"><div class="inner"><span>model</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-model-type"><div class="inner"><span>model-type</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-new-column"><div class="inner"><span>new-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-new-dataset"><div class="inner"><span>new-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-num-inference-classes"><div class="inner"><span>num-inference-classes</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-order-by"><div class="inner"><span>order-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-order-column-names"><div class="inner"><span>order-column-names</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-pivot-.3Elonger"><div class="inner"><span>pivot-&gt;longer</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-pivot-.3Ewider"><div class="inner"><span>pivot-&gt;wider</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-print-dataset"><div class="inner"><span>print-dataset</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-probability-distributions-.3Elabel-column"><div class="inner"><span>probability-distributions-&gt;label-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-process-group-data"><div class="inner"><span>process-group-data</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rand-nth"><div class="inner"><span>rand-nth</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-random"><div class="inner"><span>random</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-read-nippy"><div class="inner"><span>read-nippy</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-reduce-dimensions"><div class="inner"><span>reduce-dimensions</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-remove-column"><div class="inner"><span>remove-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-remove-columns"><div class="inner"><span>remove-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-remove-rows"><div class="inner"><span>remove-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rename-columns"><div class="inner"><span>rename-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-reorder-columns"><div class="inner"><span>reorder-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-replace-missing"><div class="inner"><span>replace-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-replace-missing-value"><div class="inner"><span>replace-missing-value</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-right-join"><div class="inner"><span>right-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-row-at"><div class="inner"><span>row-at</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-row-count"><div class="inner"><span>row-count</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-row-map"><div class="inner"><span>row-map</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rows"><div class="inner"><span>rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rowvec-at"><div class="inner"><span>rowvec-at</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-rowvecs"><div class="inner"><span>rowvecs</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-sample"><div class="inner"><span>sample</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-by-index"><div class="inner"><span>select-by-index</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-columns"><div class="inner"><span>select-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-columns-by-index"><div class="inner"><span>select-columns-by-index</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-missing"><div class="inner"><span>select-missing</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-rows"><div class="inner"><span>select-rows</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-select-rows-by-index"><div class="inner"><span>select-rows-by-index</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-semi-join"><div class="inner"><span>semi-join</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-separate-column"><div class="inner"><span>separate-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-set-dataset-name"><div class="inner"><span>set-dataset-name</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-set-inference-target"><div class="inner"><span>set-inference-target</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-shape"><div class="inner"><span>shape</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-shuffle"><div class="inner"><span>shuffle</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-sort-by"><div class="inner"><span>sort-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-sort-by-column"><div class="inner"><span>sort-by-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-std-scale"><div class="inner"><span>std-scale</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-tail"><div class="inner"><span>tail</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-take-nth"><div class="inner"><span>take-nth</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-ungroup"><div class="inner"><span>ungroup</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unique-by"><div class="inner"><span>unique-by</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unique-by-column"><div class="inner"><span>unique-by-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unmark-group"><div class="inner"><span>unmark-group</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unordered-select"><div class="inner"><span>unordered-select</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unroll"><div class="inner"><span>unroll</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-unroll-column"><div class="inner"><span>unroll-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update"><div class="inner"><span>update</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update-column"><div class="inner"><span>update-column</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update-columns"><div class="inner"><span>update-columns</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update-columnwise"><div class="inner"><span>update-columnwise</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-update-elemwise"><div class="inner"><span>update-elemwise</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-value-reader"><div class="inner"><span>value-reader</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-write.21"><div class="inner"><span>write!</span></div></a></li><li class="depth-1"><a href="scicloj.ml.metamorph.html#var-write-nippy.21"><div class="inner"><span>write-nippy!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">scicloj.ml.metamorph</h1><div class="doc"><div class="markdown"><p>This namespace contains functions, which operate on a metamorph context. They all return the context as well.</p>
<p>So all functions in this namespace are metamorph compliant and can be placed in a metamorph pipeline.</p>
<p>Most functions here are only manipulating the dataset, which is in the ctx map under the key :metamorph/data. And they behave the same in pipeline mode :fit and :transform.</p>
<p>A few functions manipulate other keys inside the ctx map, and/or behave different in :fit and :transform.</p>
<p>This is documented per function in this form:</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>.</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>.</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>.</td>
    </tr>
  </tbody>
</table>
<p>The namespaces scicloj.ml.metamorph and scicloj.ml.dataset contain functions with the same name. But they operate on either a context map (ns metamorph) or on a dataset (ns dataset)</p>
<p>The functions in this namesspaces are re-exported from :</p>
<ul>
  <li>tablecloth.pipeline</li>
  <li>tech.v3.libs.smile.metamorph</li>
  <li>scicloj.metamorph.ml</li>
  <li>tech.v3.dataset.metamorph</li>
</ul></div></div><div class="public anchor" id="var--.3Earray"><h3>-&gt;array</h3><div class="usage"><code>(-&gt;array colname)</code><code>(-&gt;array colname datatype)</code></div><div class="doc"><div class="markdown"><p>Convert numerical column(s) to java array</p></div></div></div><div class="public anchor" id="var-add-column"><h3>add-column</h3><div class="usage"><code>(add-column column-name column)</code><code>(add-column column-name column size-strategy)</code></div><div class="doc"><div class="markdown"><p>Add or update (modify) column under <code>column-name</code>.</p>
<p><code>column</code> can be sequence of values or generator function (which gets <code>ds</code> as input).</p></div></div></div><div class="public anchor" id="var-add-columns"><h3>add-columns</h3><div class="usage"><code>(add-columns columns-map)</code><code>(add-columns columns-map size-strategy)</code></div><div class="doc"><div class="markdown"><p>Add or updade (modify) columns defined in <code>columns-map</code> (mapping: name -&gt; column) </p></div></div></div><div class="public anchor" id="var-add-or-replace-column"><h3>add-or-replace-column</h3><div class="usage"><code>(add-or-replace-column column-name column)</code><code>(add-or-replace-column column-name column size-strategy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-or-replace-columns"><h3>add-or-replace-columns</h3><div class="usage"><code>(add-or-replace-columns columns-map)</code><code>(add-or-replace-columns columns-map size-strategy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-add-or-update-column"><h3>add-or-update-column</h3><div class="usage"><code>(add-or-update-column colname column)</code><code>(add-or-update-column column)</code></div><div class="doc"><div class="markdown"><p>If column exists, replace. Else append new column.</p></div></div></div><div class="public anchor" id="var-aggregate"><h3>aggregate</h3><div class="usage"><code>(aggregate aggregator)</code><code>(aggregate aggregator options)</code></div><div class="doc"><div class="markdown"><p>Aggregate dataset by providing:</p>
<ul>
  <li>aggregation function</li>
  <li>map with column names and functions</li>
  <li>sequence of aggregation functions</li>
</ul>
<p>Aggregation functions can return: - single value - seq of values - map of values with column names</p></div></div></div><div class="public anchor" id="var-aggregate-columns"><h3>aggregate-columns</h3><div class="usage"><code>(aggregate-columns columns-selector column-aggregators)</code><code>(aggregate-columns columns-selector column-aggregators options)</code></div><div class="doc"><div class="markdown"><p>Aggregates each column separately</p></div></div></div><div class="public anchor" id="var-anti-join"><h3>anti-join</h3><div class="usage"><code>(anti-join ds-right columns-selector)</code><code>(anti-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-append"><h3>append</h3><div class="usage"><code>(append &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-append-columns"><h3>append-columns</h3><div class="usage"><code>(append-columns column-seq)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-as-regular-dataset"><h3>as-regular-dataset</h3><div class="usage"><code>(as-regular-dataset)</code></div><div class="doc"><div class="markdown"><p>Remove grouping tag</p></div></div></div><div class="public anchor" id="var-asof-join"><h3>asof-join</h3><div class="usage"><code>(asof-join ds-right colname)</code><code>(asof-join ds-right colname options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-assoc-ds"><h3>assoc-ds</h3><div class="usage"><code>(assoc-ds cname cdata &amp; args)</code></div><div class="doc"><div class="markdown"><p>If dataset is not nil, calls <code>clojure.core/assoc</code>. Else creates a new empty dataset and then calls <code>clojure.core/assoc</code>. Guaranteed to return a dataset (unlike assoc).</p></div></div></div><div class="public anchor" id="var-assoc-metadata"><h3>assoc-metadata</h3><div class="usage"><code>(assoc-metadata filter-fn-or-ds k v &amp; args)</code></div><div class="doc"><div class="markdown"><p>Set metadata across a set of columns.</p></div></div></div><div class="public anchor" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-bow-.3Esomething-sparse"><h3>bow-&gt;something-sparse</h3><div class="usage"><code>(bow-&gt;something-sparse bow-col indices-col bow-&gt;sparse-fn options)</code></div><div class="doc"><div class="markdown"><p>Converts a bag-of-word column <code>bow-col</code> to a sparse data column <code>indices-col</code>.  The exact transformation to the sparse representtaion is given by <code>bow-&gt;sparse-fn</code></p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>:scicloj.ml.smile.metamorph/bow-&gt;sparse-vocabulary</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-bow-.3Esparse-array"><h3>bow-&gt;sparse-array</h3><div class="usage"><code>(bow-&gt;sparse-array bow-col indices-col options)</code><code>(bow-&gt;sparse-array bow-col indices-col)</code></div><div class="doc"><div class="markdown"><p>Converts a bag-of-word column <code>bow-col</code> to sparse indices column <code>indices-col</code>, as needed by the Maxent model. <code>Options</code> can be of:</p>
<p><code>create-vocab-fn</code> A function which converts the bow map to a list of tokens.  Defaults to scicloj.ml.smile.nlp/create-vocab-all</p>
<p>The sparse data is represented as <code>primitive int arrays</code>, of which entries are the indices against the vocabulary of the present tokens.</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>:scicloj.ml.smile.metamorph/bow-&gt;sparse-vocabulary</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-bow-.3ESparseArray"><h3>bow-&gt;SparseArray</h3><div class="usage"><code>(bow-&gt;SparseArray bow-col indices-col options)</code><code>(bow-&gt;SparseArray bow-col indices-col)</code></div><div class="doc"><div class="markdown"><p>Converts a bag-of-word column <code>bow-col</code> to sparse indices column <code>indices-col</code>,  as needed by the discrete naive bayes model.</p>
<p><code>Options</code> can be of:</p>
<p><code>create-vocab-fn</code> A function which converts the bow map to a list of tokens.  Defaults to scicloj.ml.smile.nlp/create-vocab-all</p>
<p>The sparse data is represented as <code>smile.util.SparseArray</code>.</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>:scicloj.ml.smile.metamorph/bow-&gt;sparse-vocabulary</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-bow-.3Etfidf"><h3>bow-&gt;tfidf</h3><div class="usage"><code>(bow-&gt;tfidf bow-column tfidf-column)</code></div><div class="doc"><div class="markdown"><p>Calculates the tfidf score from bag-of-words (as token frequency maps)  in column <code>bow-column</code> and stores them in a new column <code>tfid-column</code> as maps of token-&gt;tfidf-score.</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>none</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-brief"><h3>brief</h3><div class="usage"><code>(brief options)</code><code>(brief)</code></div><div class="doc"><div class="markdown"><p>Get a brief description, in mapseq form of a dataset. A brief description is the mapseq form of descriptive stats.</p></div></div></div><div class="public anchor" id="var-by-rank"><h3>by-rank</h3><div class="usage"><code>(by-rank columns-selector rank-predicate)</code><code>(by-rank columns-selector rank-predicate options)</code></div><div class="doc"><div class="markdown"><p>Select rows using <code>rank</code> on a column, ties are resolved using <code>:dense</code> method.</p>
<p>See <a href="https://www.rdocumentation.org/packages/base/versions/3.6.1/topics/rank">R docs</a>. Rank uses 0 based indexing.</p>
<p>Possible <code>:ties</code> strategies: <code>:average</code>, <code>:first</code>, <code>:last</code>, <code>:random</code>, <code>:min</code>, <code>:max</code>, <code>:dense</code>. <code>:dense</code> is the same as in <code>data.table::frank</code> from R</p>
<p><code>:desc?</code> set to true (default) order descending before calculating rank</p></div></div></div><div class="public anchor" id="var-categorical-.3Enumber"><h3>categorical-&gt;number</h3><div class="usage"><code>(categorical-&gt;number filter-fn-or-ds)</code><code>(categorical-&gt;number filter-fn-or-ds table-args)</code><code>(categorical-&gt;number filter-fn-or-ds table-args result-datatype)</code></div><div class="doc"><div class="markdown"><p>Convert columns into a discrete , numeric representation See tech.v3.dataset.categorical/fit-categorical-map.</p></div></div></div><div class="public anchor" id="var-categorical-.3Eone-hot"><h3>categorical-&gt;one-hot</h3><div class="usage"><code>(categorical-&gt;one-hot filter-fn-or-ds)</code><code>(categorical-&gt;one-hot filter-fn-or-ds table-args)</code><code>(categorical-&gt;one-hot filter-fn-or-ds table-args result-datatype)</code></div><div class="doc"><div class="markdown"><p>Convert string columns to numeric columns. See tech.v3.dataset.categorical/fit-one-hot</p></div></div></div><div class="public anchor" id="var-clone"><h3>clone</h3><div class="usage"><code>(clone)</code></div><div class="doc"><div class="markdown"><p>Clone an object. Can clone anything convertible to a reader.</p></div></div></div><div class="public anchor" id="var-cluster"><h3>cluster</h3><div class="usage"><code>(cluster clustering-method clustering-method-args target-column)</code></div><div class="doc"><div class="markdown"><p>Metamorph transformer, which clusters the data and creates a new column with the cluster id.</p>
<p><code>clustering-method</code> can be any of:</p>
<ul>
  <li>:spectral</li>
  <li>:dbscan</li>
  <li>:k-means</li>
  <li>:mec</li>
  <li>:clarans</li>
  <li>:g-means</li>
  <li>:lloyd</li>
  <li>:x-means</li>
  <li>:deterministic-annealing</li>
  <li>:denclue</li>
</ul>
<p>The <code>clustering-args</code> is a vector with the positional arguments for each cluster function, as documented here: <a href="https://cljdoc.org/d/generateme/fastmath/2.1.5/api/fastmath.clustering">https://cljdoc.org/d/generateme/fastmath/2.1.5/api/fastmath.clustering</a></p>
<p>The cluster id of each row gets written to the column in <code>target-column</code></p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Calculates cluster centers of the rows dataset at key <code>:metamorph/data</code> and stores them in ctx under key at <code>:metamorph/id</code>. Adds as wll column in <code>target-column</code> with cluster centers into the dataset.</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads cluster centers from ctx and applies it to data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads cluster centers to use from ctx at key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores cluster centers in ctx under key in <code>:metamorph/id</code>.</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-column"><h3>column</h3><div class="usage"><code>(column colname)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-.3Edataset"><h3>column-&gt;dataset</h3><div class="usage"><code>(column-&gt;dataset colname transform-fn options)</code><code>(column-&gt;dataset colname transform-fn)</code></div><div class="doc"><div class="markdown"><p>Transform a column into a sequence of maps using transform-fn. Return dataset created out of the sequence of maps.</p></div></div></div><div class="public anchor" id="var-column-cast"><h3>column-cast</h3><div class="usage"><code>(column-cast colname datatype)</code></div><div class="doc"><div class="markdown"><p>Cast a column to a new datatype. This is never a lazy operation. If the old and new datatypes match and no cast-fn is provided then dtype/clone is called on the column.</p>
<p>colname may be a scalar or a tuple of [src-col dst-col].</p>
<p>datatype may be a datatype enumeration or a tuple of [datatype cast-fn] where cast-fn may return either a new value, :tech.v3.dataset/missing, or :tech.v3.dataset/parse-failure. Exceptions are propagated to the caller. The new column has at least the existing missing set (if no attempt returns :missing or :cast-failure). :cast-failure means the value gets added to metadata key :unparsed-data and the index gets added to :unparsed-indexes.</p>
<p>If the existing datatype is string, then tech.v3.datatype.column/parse-column is called.</p>
<p>Casts between numeric datatypes need no cast-fn but one may be provided. Casts to string need no cast-fn but one may be provided. Casts from string to anything will call tech.v3.dataset.column/parse-column.</p></div></div></div><div class="public anchor" id="var-column-count"><h3>column-count</h3><div class="usage"><code>(column-count)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-labeled-mapseq"><h3>column-labeled-mapseq</h3><div class="usage"><code>(column-labeled-mapseq value-colname-seq)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a sequence of maps where several columns are all stored  in a :value key and a :label key contains a column name. Used for quickly creating  timeseries or scatterplot labeled graphs. Returns a lazy sequence, not a reader!</p>
<p>See also <code>columnwise-concat</code></p>
<p>Return a sequence of maps with</p>
<pre><code class="clojure">  {... - columns not in colname-seq
   :value - value from one of the value columns
   :label - name of the column the value came from
  }
</code></pre></div></div></div><div class="public anchor" id="var-column-map"><h3>column-map</h3><div class="usage"><code>(column-map result-colname map-fn res-dtype-or-opts filter-fn-or-ds)</code><code>(column-map result-colname map-fn filter-fn-or-ds)</code><code>(column-map result-colname map-fn)</code></div><div class="doc"><div class="markdown"><p>Produce a new (or updated) column as the result of mapping a fn over columns.</p>
<ul>
  <li><code>dataset</code> - dataset.</li>
  <li><code>result-colname</code> - Name of new (or existing) column.</li>
  <li><code>map-fn</code> - function to map over columns. Same rules as <code>tech.v3.datatype/emap</code>.</li>
  <li><code>res-dtype-or-opts</code> - If not given result is scanned to infer missing and datatype.  If using an option map, options are described below.</li>
  <li><code>filter-fn-or-ds</code> - A dataset, a sequence of columns, or a <code>tech.v3.datasets/column-filters</code>  column filter function. Defaults to all the columns of the existing dataset.</li>
</ul>
<p>Returns a new dataset with a new or updated column.</p>
<p>Options:</p>
<ul>
  <li><code>:datatype</code> - Set the dataype of the result column. If not given result is scanned  to infer result datatype and missing set.</li>
  <li><code>:missing-fn</code> - if given, columns are first passed to missing-fn as a sequence and  this dictates the missing set. Else the missing set is by scanning the results  during the inference process. See <code>tech.v3.dataset.column/union-missing-sets</code> and  <code>tech.v3.dataset.column/intersect-missing-sets</code> for example functions to pass in  here.</li>
</ul>
<p>Examples:</p>
<pre><code class="clojure"><br />  ;;From the tests --

  (let [testds (ds/-&gt;dataset [{:a 1.0 :b 2.0} {:a 3.0 :b 5.0} {:a 4.0 :b nil}])]
    ;;result scanned for both datatype and missing set
    (is (= (vec [3.0 6.0 nil])
           (:b2 (ds/column-map testds :b2 #(when % (inc %)) [:b]))))
    ;;result scanned for missing set only.  Result used in-place.
    (is (= (vec [3.0 6.0 nil])
           (:b2 (ds/column-map testds :b2 #(when % (inc %))
                               {:datatype :float64} [:b]))))
    ;;Nothing scanned at all.
    (is (= (vec [3.0 6.0 nil])
           (:b2 (ds/column-map testds :b2 #(inc %)
                               {:datatype :float64
                                :missing-fn ds-col/union-missing-sets} [:b]))))
    ;;Missing set scanning causes NPE at inc.
    (is (thrown? Throwable
                 (ds/column-map testds :b2 #(inc %)
                                {:datatype :float64}
                                [:b]))))

  ;;Ad-hoc repl --

user&gt; (require '[tech.v3.dataset :as ds]))
nil
user&gt; (def ds (ds/-&gt;dataset "test/data/stocks.csv"))
#'user/ds
user&gt; (ds/head ds)
test/data/stocks.csv [5 3]:

| symbol |       date | price |
|--------|------------|-------|
|   MSFT | 2000-01-01 | 39.81 |
|   MSFT | 2000-02-01 | 36.35 |
|   MSFT | 2000-03-01 | 43.22 |
|   MSFT | 2000-04-01 | 28.37 |
|   MSFT | 2000-05-01 | 25.45 |
user&gt; (-&gt; (ds/column-map ds "price^2" #(* % %) ["price"])
          (ds/head))
test/data/stocks.csv [5 4]:

| symbol |       date | price |   price^2 |
|--------|------------|-------|-----------|
|   MSFT | 2000-01-01 | 39.81 | 1584.8361 |
|   MSFT | 2000-02-01 | 36.35 | 1321.3225 |
|   MSFT | 2000-03-01 | 43.22 | 1867.9684 |
|   MSFT | 2000-04-01 | 28.37 |  804.8569 |
|   MSFT | 2000-05-01 | 25.45 |  647.7025 |



user&gt; (def ds1 (ds/-&gt;dataset [{:a 1} {:b 2.0} {:a 2 :b 3.0}]))
#'user/ds1
user&gt; ds1
_unnamed [3 2]:

|  :b | :a |
|----:|---:|
|     |  1 |
| 2.0 |    |
| 3.0 |  2 |
user&gt; (ds/column-map ds1 :c (fn [a b]
                              (when (and a b)
                                (+ (double a) (double b))))
                     [:a :b])
_unnamed [3 3]:

|  :b | :a |  :c |
|----:|---:|----:|
|     |  1 |     |
| 2.0 |    |     |
| 3.0 |  2 | 5.0 |
user&gt; (ds/missing (*1 :c))
{0,1}
</code></pre></div></div></div><div class="public anchor" id="var-column-names"><h3>column-names</h3><div class="usage"><code>(column-names)</code><code>(column-names columns-selector)</code><code>(column-names columns-selector meta-field)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-column-values-.3Ecategorical"><h3>column-values-&gt;categorical</h3><div class="usage"><code>(column-values-&gt;categorical src-column)</code></div><div class="doc"><div class="markdown"><p>Given a column encoded via either string-&gt;number or one-hot, reverse map to the a sequence of the original string column values. In the case of one-hot mappings, src-column must be the original column name before the one-hot map</p></div></div></div><div class="public anchor" id="var-columns"><h3>columns</h3><div class="usage"><code>(columns)</code><code>(columns result-type)</code></div><div class="doc"><div class="markdown"><p>Returns columns of dataset. Result type can be any of: * <code>:as-map</code> * <code>:as-double-arrays</code> * <code>:as-seqs</code></p></div></div></div><div class="public anchor" id="var-columns-with-missing-seq"><h3>columns-with-missing-seq</h3><div class="usage"><code>(columns-with-missing-seq)</code></div><div class="doc"><div class="markdown"><p>Return a sequence of:</p>
<pre><code class="clojure">  {:column-name column-name
   :missing-count missing-count
  }
</code></pre>
<p>or nil of no columns are missing data.</p></div></div></div><div class="public anchor" id="var-columnwise-concat"><h3>columnwise-concat</h3><div class="usage"><code>(columnwise-concat colnames options)</code><code>(columnwise-concat colnames)</code></div><div class="doc"><div class="markdown"><p>Given a dataset and a list of columns, produce a new dataset with  the columns concatenated to a new column with a :column column indicating  which column the original value came from. Any columns not mentioned in the  list of columns are duplicated.</p>
<p>Example:</p>
<pre><code class="clojure">user&gt; (-&gt; [{:a 1 :b 2 :c 3 :d 1} {:a 4 :b 5 :c 6 :d 2}]
          (ds/-&gt;dataset)
          (ds/columnwise-concat [:c :a :b]))
null [6 3]:

| :column | :value | :d |
|---------+--------+----|
|      :c |      3 |  1 |
|      :c |      6 |  2 |
|      :a |      1 |  1 |
|      :a |      4 |  2 |
|      :b |      2 |  1 |
|      :b |      5 |  2 |
</code></pre>
<p>Options:</p>
<p>value-column-name - defaults to :value  colname-column-name - defaults to :column</p></div></div></div><div class="public anchor" id="var-concat"><h3>concat</h3><div class="usage"><code>(concat &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-concat-copying"><h3>concat-copying</h3><div class="usage"><code>(concat-copying &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-concat-inplace"><h3>concat-inplace</h3><div class="usage"><code>(concat-inplace &amp; datasets)</code></div><div class="doc"><div class="markdown"><p>Concatenate datasets in place. Respects missing values. Datasets must all have the same columns. Result column datatypes will be a widening cast of the datatypes.</p></div></div></div><div class="public anchor" id="var-convert-types"><h3>convert-types</h3><div class="usage"><code>(convert-types coltype-map-or-columns-selector)</code><code>(convert-types columns-selector new-types)</code></div><div class="doc"><div class="markdown"><p>Convert type of the column to the other type.</p></div></div></div><div class="public anchor" id="var-count-vectorize"><h3>count-vectorize</h3><div class="usage"><code>(count-vectorize text-col bow-col options)</code><code>(count-vectorize text-col bow-col)</code></div><div class="doc"><div class="markdown"><p>Transforms the text column <code>text-col</code> into a map of token frequencies in column <code>bow-col</code></p>
<p><code>options</code> can be any of</p>
<p><code>text-&gt;bow-fn</code> A functions which takes as input a</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>normal</td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>none</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>none</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-data-.3Edataset"><h3>data-&gt;dataset</h3><div class="usage"><code>(data-&gt;dataset)</code></div><div class="doc"><div class="markdown"><p>Convert a data-ized dataset created via dataset-&gt;data back into a full dataset</p></div></div></div><div class="public anchor" id="var-dataset-.3Ecategorical-xforms"><h3>dataset-&gt;categorical-xforms</h3><div class="usage"><code>(dataset-&gt;categorical-xforms)</code></div><div class="doc"><div class="markdown"><p>Given a dataset, return a map of column-name-&gt;xform information.</p></div></div></div><div class="public anchor" id="var-dataset-.3Edata"><h3>dataset-&gt;data</h3><div class="usage"><code>(dataset-&gt;data)</code></div><div class="doc"><div class="markdown"><p>Convert a dataset to a pure clojure datastructure. Returns a map with two keys: {:metadata :columns}. :columns is a vector of column definitions appropriate for passing directly back into new-dataset. A column definition in this case is a map of {:name :missing :data :metadata}.</p></div></div></div><div class="public anchor" id="var-dataset-.3Estr"><h3>dataset-&gt;str</h3><div class="usage"><code>(dataset-&gt;str options)</code><code>(dataset-&gt;str)</code></div><div class="doc"><div class="markdown"><p>Convert a dataset to a string. Prints a single line header and then calls dataset-data-&gt;str.</p>
<p>For options documentation see dataset-data-&gt;str.</p></div></div></div><div class="public anchor" id="var-dataset-name"><h3>dataset-name</h3><div class="usage"><code>(dataset-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-dataset.3F"><h3>dataset?</h3><div class="usage"><code>(dataset?)</code></div><div class="doc"><div class="markdown"><p>Is <code>ds</code> a <code>dataset</code> type?</p></div></div></div><div class="public anchor" id="var-descriptive-stats"><h3>descriptive-stats</h3><div class="usage"><code>(descriptive-stats)</code><code>(descriptive-stats options)</code></div><div class="doc"><div class="markdown"><p>Get descriptive statistics across the columns of the dataset. In addition to the standard stats. Options: :stat-names - defaults to (remove #{:values :num-distinct-values}  (all-descriptive-stats-names)) :n-categorical-values - Number of categorical values to report in the values  field. Defaults to 21.</p></div></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><div class="usage"><code>(difference ds-right)</code><code>(difference ds-right options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-drop"><h3>drop</h3><div class="usage"><code>(drop columns-selector rows-selector)</code></div><div class="doc"><div class="markdown"><p>Drop columns and rows.</p></div></div></div><div class="public anchor" id="var-drop-columns"><h3>drop-columns</h3><div class="usage"><code>(drop-columns)</code><code>(drop-columns columns-selector)</code><code>(drop-columns columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Drop columns by (returns dataset):</p>
<ul>
  <li>name</li>
  <li>sequence of names</li>
  <li>map of names with new names (rename)</li>
  <li>function which filter names (via column metadata)</li>
</ul></div></div></div><div class="public anchor" id="var-drop-missing"><h3>drop-missing</h3><div class="usage"><code>(drop-missing)</code><code>(drop-missing columns-selector)</code></div><div class="doc"><div class="markdown"><p>Drop rows with missing values</p>
<p><code>columns-selector</code> selects columns to look at missing values</p></div></div></div><div class="public anchor" id="var-drop-rows"><h3>drop-rows</h3><div class="usage"><code>(drop-rows)</code><code>(drop-rows rows-selector)</code><code>(drop-rows rows-selector options)</code></div><div class="doc"><div class="markdown"><p>Drop rows using:</p>
<ul>
  <li>row id</li>
  <li>seq of row ids</li>
  <li>seq of true/false</li>
  <li>fn with predicate</li>
</ul></div></div></div><div class="public anchor" id="var-empty-ds.3F"><h3>empty-ds?</h3><div class="usage"><code>(empty-ds?)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-ensure-array-backed"><h3>ensure-array-backed</h3><div class="usage"><code>(ensure-array-backed options)</code><code>(ensure-array-backed)</code></div><div class="doc"><div class="markdown"><p>Ensure the column data in the dataset is stored in pure java arrays. This is sometimes necessary for interop with other libraries and this operation will force any lazy computations to complete. This also clears the missing set for each column and writes the missing values to the new arrays.</p>
<p>Columns that are already array backed and that have no missing values are not changed and retuned.</p>
<p>The postcondition is that dtype/-&gt;array will return a java array in the appropriate datatype for each column.</p>
<p>options - :unpack? - unpack packed datetime types. Defaults to true</p></div></div></div><div class="public anchor" id="var-feature-ecount"><h3>feature-ecount</h3><div class="usage"><code>(feature-ecount)</code></div><div class="doc"><div class="markdown"><p>Number of feature columns. Feature columns are columns that are not inference targets.</p></div></div></div><div class="public anchor" id="var-fill-range-replace"><h3>fill-range-replace</h3><div class="usage"><code>(fill-range-replace colname max-span)</code><code>(fill-range-replace colname max-span missing-strategy)</code><code>(fill-range-replace colname max-span missing-strategy missing-value)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-filter"><h3>filter</h3><div class="usage"><code>(filter predicate)</code></div><div class="doc"><div class="markdown"><p>dataset-&gt;dataset transformation. Predicate is passed a map of colname-&gt;column-value.</p></div></div></div><div class="public anchor" id="var-filter-column"><h3>filter-column</h3><div class="usage"><code>(filter-column colname predicate)</code></div><div class="doc"><div class="markdown"><p>Filter a given column by a predicate. Predicate is passed column values. If predicate is <em>not</em> an instance of Ifn it is treated as a value and will be used as if the predicate is #(= value %). Returns a dataset.</p></div></div></div><div class="public anchor" id="var-filter-dataset"><h3>filter-dataset</h3><div class="usage"><code>(filter-dataset filter-fn-or-ds)</code></div><div class="doc"><div class="markdown"><p>Filter the columns of the dataset returning a new dataset. This pathway is designed to work with the tech.v3.dataset.column-filters namespace.</p>
<ul>
  <li>If filter-fn-or-ds is a dataset, it is returned.</li>
  <li>If filter-fn-or-ds is sequential, then select-columns is called.</li>
  <li>If filter-fn-or-ds is :all, all columns are returned</li>
  <li>If filter-fn-or-ds is an instance of IFn, the dataset is passed into it.</li>
</ul></div></div></div><div class="public anchor" id="var-first"><h3>first</h3><div class="usage"><code>(first)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-fold-by"><h3>fold-by</h3><div class="usage"><code>(fold-by columns-selector)</code><code>(fold-by columns-selector folding-function)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-full-join"><h3>full-join</h3><div class="usage"><code>(full-join ds-right columns-selector)</code><code>(full-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-group-by"><h3>group-by</h3><div class="usage"><code>(group-by grouping-selector)</code><code>(group-by grouping-selector options)</code></div><div class="doc"><div class="markdown"><p>Group dataset by:</p>
<ul>
  <li>column name</li>
  <li>list of columns</li>
  <li>map of keys and row indexes</li>
  <li>function getting map of values</li>
</ul>
<p>Options are:</p>
<ul>
  <li>select-keys - when grouping is done by function, you can limit fields to a <code>select-keys</code> seq.</li>
  <li>result-type - return results as dataset (<code>:as-dataset</code>, default) or as map of datasets (<code>:as-map</code>) or as map of row indexes (<code>:as-indexes</code>) or as sequence of (sub)datasets</li>
  <li>other parameters which are passed to <code>dataset</code> fn</li>
</ul>
<p>When dataset is returned, meta contains <code>:grouped?</code> set to true. Columns in dataset:</p>
<ul>
  <li>name - group name</li>
  <li>group-id - id of the group (int)</li>
  <li>data - group as dataset</li>
</ul></div></div></div><div class="public anchor" id="var-group-by-.3Eindexes"><h3>group-by-&gt;indexes</h3><div class="usage"><code>(group-by-&gt;indexes key-fn)</code></div><div class="doc"><div class="markdown"><p>(Non-lazy) - Group a dataset and return a map of key-fn-value-&gt;indexes where indexes is an in-order contiguous group of indexes.</p></div></div></div><div class="public anchor" id="var-group-by-column"><h3>group-by-column</h3><div class="usage"><code>(group-by-column colname)</code></div><div class="doc"><div class="markdown"><p>Return a map of column-value-&gt;dataset.</p></div></div></div><div class="public anchor" id="var-group-by-column-.3Eindexes"><h3>group-by-column-&gt;indexes</h3><div class="usage"><code>(group-by-column-&gt;indexes colname)</code></div><div class="doc"><div class="markdown"><p>(Non-lazy) - Group a dataset by a column return a map of column-val-&gt;indexes where indexes is an in-order contiguous group of indexes.</p></div></div></div><div class="public anchor" id="var-grouped.3F"><h3>grouped?</h3><div class="usage"><code>(grouped?)</code></div><div class="doc"><div class="markdown"><p>Is <code>dataset</code> represents grouped dataset (result of <code>group-by</code>)?</p></div></div></div><div class="public anchor" id="var-groups-.3Emap"><h3>groups-&gt;map</h3><div class="usage"><code>(groups-&gt;map)</code></div><div class="doc"><div class="markdown"><p>Convert grouped dataset to the map of groups</p></div></div></div><div class="public anchor" id="var-groups-.3Eseq"><h3>groups-&gt;seq</h3><div class="usage"><code>(groups-&gt;seq)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-has-column.3F"><h3>has-column?</h3><div class="usage"><code>(has-column? column-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-head"><h3>head</h3><div class="usage"><code>(head)</code><code>(head n)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-inference-column.3F"><h3>inference-column?</h3><div class="usage"><code>(inference-column?)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-inference-target-column-names"><h3>inference-target-column-names</h3><div class="usage"><code>(inference-target-column-names)</code></div><div class="doc"><div class="markdown"><p>Return the names of the columns that are inference targets.</p></div></div></div><div class="public anchor" id="var-inference-target-ds"><h3>inference-target-ds</h3><div class="usage"><code>(inference-target-ds)</code></div><div class="doc"><div class="markdown"><p>Given a dataset return reverse-mapped inference target columns or nil in the case where there are no inference targets.</p></div></div></div><div class="public anchor" id="var-inference-target-label-inverse-map"><h3>inference-target-label-inverse-map</h3><div class="usage"><code>(inference-target-label-inverse-map &amp; [label-columns])</code></div><div class="doc"><div class="markdown"><p>Given options generated during ETL operations and annotated with :label-columns sequence container 1 label column, generate a reverse map that maps from a dataset value back to the label that generated that value.</p></div></div></div><div class="public anchor" id="var-inference-target-label-map"><h3>inference-target-label-map</h3><div class="usage"><code>(inference-target-label-map &amp; [label-columns])</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-info"><h3>info</h3><div class="usage"><code>(info)</code><code>(info result-type)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-inner-join"><h3>inner-join</h3><div class="usage"><code>(inner-join ds-right columns-selector)</code><code>(inner-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-intersect"><h3>intersect</h3><div class="usage"><code>(intersect ds-right)</code><code>(intersect ds-right options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-join-columns"><h3>join-columns</h3><div class="usage"><code>(join-columns target-column columns-selector)</code><code>(join-columns target-column columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-labels"><h3>labels</h3><div class="usage"><code>(labels)</code></div><div class="doc"><div class="markdown"><p>Return the labels. The labels sequence is the reverse mapped inference column. This returns a single column of data or errors out.</p></div></div></div><div class="public anchor" id="var-last"><h3>last</h3><div class="usage"><code>(last)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-left-join"><h3>left-join</h3><div class="usage"><code>(left-join ds-right columns-selector)</code><code>(left-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-map-columns"><h3>map-columns</h3><div class="usage"><code>(map-columns column-name map-fn)</code><code>(map-columns column-name columns-selector map-fn)</code><code>(map-columns column-name new-type columns-selector map-fn)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-mapseq-reader"><h3>mapseq-reader</h3><div class="usage"><code>(mapseq-reader)</code></div><div class="doc"><div class="markdown"><p>Return a reader that produces a map of column-name-&gt;column-value</p>
<p>Options: :missing-nil? - Default to true - Substitute nil in for missing values to make  missing value detection downstream to be column datatype independent.</p></div></div></div><div class="public anchor" id="var-mark-as-group"><h3>mark-as-group</h3><div class="usage"><code>(mark-as-group)</code></div><div class="doc"><div class="markdown"><p>Add grouping tag</p></div></div></div><div class="public anchor" id="var-min-max-scale"><h3>min-max-scale</h3><div class="usage"><code>(min-max-scale col-seq {:keys [min max], :or {min -0.5, max 0.5}, :as options})</code></div><div class="doc"><div class="markdown"><p>Metamorph transfomer, which scales the column data into a given range.</p>
<p><code>col-seq</code> is a sequence of columns names to work on</p>
<p><code>options</code> Options for scaler, can take:</p>
<p><code>min</code> Minimal value to scale to (default -0.5)</p>
<p><code>max</code> Maximum value to scale to (default 0.5)</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Scales the dataset at key <code>:metamorph/data</code> and stores the trained model in ctx under key at <code>:metamorph/id</code></td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads trained min-max-scale model from ctx and applies it to data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads trained model to use for from key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores trained model in key $id</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-min-n-by-column"><h3>min-n-by-column</h3><div class="usage"><code>(min-n-by-column cname N comparator options)</code><code>(min-n-by-column cname N comparator)</code><code>(min-n-by-column cname N)</code></div><div class="doc"><div class="markdown"><p>Find the minimum N entries (unsorted) by column. Resulting data will be indexed in  original order. If you want a sorted order then sort the result.</p>
<p>See options to <a href="scicloj.ml.metamorph.html#var-sort-by-column">sort-by-column</a>.</p>
<p>Example:</p>
<pre><code class="clojure">user&gt; (ds/min-n-by-column ds "price" 10 nil nil)
test/data/stocks.csv [10 3]:

| symbol |       date | price |
|--------|------------|------:|
|   AMZN | 2001-09-01 |  5.97 |
|   AMZN | 2001-10-01 |  6.98 |
|   AAPL | 2000-12-01 |  7.44 |
|   AAPL | 2002-08-01 |  7.38 |
|   AAPL | 2002-09-01 |  7.25 |
|   AAPL | 2002-12-01 |  7.16 |
|   AAPL | 2003-01-01 |  7.18 |
|   AAPL | 2003-02-01 |  7.51 |
|   AAPL | 2003-03-01 |  7.07 |
|   AAPL | 2003-04-01 |  7.11 |
user&gt; (ds/min-n-by-column ds "price" 10 &gt; nil)
test/data/stocks.csv [10 3]:

| symbol |       date |  price |
|--------|------------|-------:|
|   GOOG | 2007-09-01 | 567.27 |
|   GOOG | 2007-10-01 | 707.00 |
|   GOOG | 2007-11-01 | 693.00 |
|   GOOG | 2007-12-01 | 691.48 |
|   GOOG | 2008-01-01 | 564.30 |
|   GOOG | 2008-04-01 | 574.29 |
|   GOOG | 2008-05-01 | 585.80 |
|   GOOG | 2009-11-01 | 583.00 |
|   GOOG | 2009-12-01 | 619.98 |
|   GOOG | 2010-03-01 | 560.19 |
</code></pre></div></div></div><div class="public anchor" id="var-missing"><h3>missing</h3><div class="usage"><code>(missing)</code></div><div class="doc"><div class="markdown"><p>Given a dataset or a column, return the missing set as a roaring bitmap</p></div></div></div><div class="public anchor" id="var-model"><h3>model</h3><div class="usage"><code>(model options)</code></div><div class="doc"><div class="markdown"><p>Executes a machine learning model in train/predict (depending on :mode) from the <code>metamorph.ml</code> model registry.</p>
<p>The model is passed between both invocation via the shared context ctx in a key (a step indentifier) which is passed in key <code>:metamorph/id</code> and guarantied to be unique for each pipeline step.</p>
<p>The function writes and reads into this common context key.</p>
<p>Options: - <code>:model-type</code> - Keyword for the model to use</p>
<p>Further options get passed to <code>train</code> functions and are model specific.</p>
<p>See here for an overview for the models build into scicloj.ml:</p>
<p><a href="https://scicloj.github.io/scicloj.ml-tutorials/userguide-models.html">https://scicloj.github.io/scicloj.ml-tutorials/userguide-models.html</a></p>
<p>Other libraries might contribute other models, which are documented as part of the library.</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Calls <code>scicloj.metamorph.ml/train</code> using data in <code>:metamorph/data</code> and <code>options</code>and stores trained model in ctx under key in <code>:metamorph/id</code></td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads trained model from ctx and calls <code>scicloj.metamorph.ml/predict</code> with the model in $id and data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads trained model to use for prediction from key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores trained model in key $id and writes feature-ds and target-ds before prediction into ctx at <code>:scicloj.metamorph.ml/feature-ds</code> /<code>:scicloj.metamorph.ml/target-ds</code></td>
    </tr>
  </tbody>
</table>
<p>See as well:</p>
<ul>
  <li><code>scicloj.metamorph.ml/train</code></li>
  <li><code>scicloj.metamorph.ml/predict</code></li>
</ul></div></div></div><div class="public anchor" id="var-model-type"><h3>model-type</h3><div class="usage"><code>(model-type &amp; [column-name-seq])</code></div><div class="doc"><div class="markdown"><p>Check the label column after dataset processing. Return either :regression :classification</p></div></div></div><div class="public anchor" id="var-new-column"><h3>new-column</h3><div class="usage"><code>(new-column data)</code><code>(new-column data metadata)</code><code>(new-column data metadata missing)</code><code>(new-column)</code></div><div class="doc"><div class="markdown"><p>Create a new column. Data will scanned for missing values unless the full 4-argument pathway is used.</p></div></div></div><div class="public anchor" id="var-new-dataset"><h3>new-dataset</h3><div class="usage"><code>(new-dataset ds-metadata column-seq)</code><code>(new-dataset column-seq)</code><code>(new-dataset)</code></div><div class="doc"><div class="markdown"><p>Create a new dataset from a sequence of columns. Data will be converted into columns using ds-col-proto/ensure-column-seq. If the column seq is simply a collection of vectors, for instance, columns will be named ordinally. options map -  :dataset-name - Name of the dataset. Defaults to "_unnamed".  :key-fn - Key function used on all column names before insertion into dataset.</p>
<p>The return value fulfills the dataset protocols.</p></div></div></div><div class="public anchor" id="var-num-inference-classes"><h3>num-inference-classes</h3><div class="usage"><code>(num-inference-classes)</code></div><div class="doc"><div class="markdown"><p>Given a dataset and correctly built options from pipeline operations, return the number of classes used for the label. Error if not classification dataset.</p></div></div></div><div class="public anchor" id="var-order-by"><h3>order-by</h3><div class="usage"><code>(order-by columns-or-fn)</code><code>(order-by columns-or-fn comparators)</code><code>(order-by columns-or-fn comparators options)</code></div><div class="doc"><div class="markdown"><p>Order dataset by: - column name - columns (as sequence of names) - key-fn - sequence of columns / key-fn Additionally you can ask the order by: - :asc - :desc - custom comparator function</p></div></div></div><div class="public anchor" id="var-order-column-names"><h3>order-column-names</h3><div class="usage"><code>(order-column-names colname-seq)</code></div><div class="doc"><div class="markdown"><p>Order a sequence of columns names so they match the order in the original dataset. Missing columns are placed last.</p></div></div></div><div class="public anchor" id="var-pivot-.3Elonger"><h3>pivot-&gt;longer</h3><div class="usage"><code>(pivot-&gt;longer)</code><code>(pivot-&gt;longer columns-selector)</code><code>(pivot-&gt;longer columns-selector options)</code></div><div class="doc"><div class="markdown"><p><code>tidyr</code> pivot_longer api</p></div></div></div><div class="public anchor" id="var-pivot-.3Ewider"><h3>pivot-&gt;wider</h3><div class="usage"><code>(pivot-&gt;wider columns-selector value-columns)</code><code>(pivot-&gt;wider columns-selector value-columns options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-print-dataset"><h3>print-dataset</h3><div class="usage"><code>(print-dataset)</code><code>(print-dataset options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-probability-distributions-.3Elabel-column"><h3>probability-distributions-&gt;label-column</h3><div class="usage"><code>(probability-distributions-&gt;label-column dst-colname)</code></div><div class="doc"><div class="markdown"><p>Given a dataset that has columns in which the column names describe labels and the rows describe a probability distribution, create a label column by taking the max value in each row and assign column that row value.</p></div></div></div><div class="public anchor" id="var-process-group-data"><h3>process-group-data</h3><div class="usage"><code>(process-group-data f)</code><code>(process-group-data f parallel?)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-rand-nth"><h3>rand-nth</h3><div class="usage"><code>(rand-nth)</code><code>(rand-nth options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-random"><h3>random</h3><div class="usage"><code>(random)</code><code>(random n)</code><code>(random n options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-read-nippy"><h3>read-nippy</h3><div class="usage"><code>(read-nippy)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-reduce-dimensions"><h3>reduce-dimensions</h3><div class="usage"><code>(reduce-dimensions algorithm target-dims cnames opts)</code></div><div class="doc"><div class="markdown"><p>Metamorph transformer, which reduces the dimensions of a given dataset.</p>
<p><code>algorithm</code> can be any of:  * :pca-cov  * :pca-cor  * :pca-prob  * :kpca  * :gha  * :random</p>
<p><code>target-dims</code> is number of dimensions to reduce to.</p>
<p><code>cnames</code> is a sequence of column names on which the reduction get performed</p>
<p><code>opts</code> are the options of the algorithm</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Reduces dimensions of the dataset at key <code>:metamorph/data</code> and stores the trained model in ctx under key at <code>:metamorph/id</code></td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads trained reduction model from ctx and applies it to data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads trained model to use from ctx at key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores trained model in ctx under key in <code>:metamorph/id</code>.</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-remove-column"><h3>remove-column</h3><div class="usage"><code>(remove-column col-name)</code></div><div class="doc"><div class="markdown"><p>Same as:</p>
<pre><code class="clojure">(dissoc dataset col-name)
</code></pre></div></div></div><div class="public anchor" id="var-remove-columns"><h3>remove-columns</h3><div class="usage"><code>(remove-columns colname-seq-or-fn)</code></div><div class="doc"><div class="markdown"><p>Remove columns indexed by column name seq or column filter function.  For example:</p>
<pre><code class="clojure">  (remove-columns DS [:A :B])
  (remove-columns DS cf/categorical)
</code></pre></div></div></div><div class="public anchor" id="var-remove-rows"><h3>remove-rows</h3><div class="usage"><code>(remove-rows row-indexes)</code></div><div class="doc"><div class="markdown"><p>Same as drop-rows.</p></div></div></div><div class="public anchor" id="var-rename-columns"><h3>rename-columns</h3><div class="usage"><code>(rename-columns columns-selector columns-map-fn)</code><code>(rename-columns columns-mapping)</code></div><div class="doc"><div class="markdown"><p>Rename columns with provided old -&gt; new name map</p></div></div></div><div class="public anchor" id="var-reorder-columns"><h3>reorder-columns</h3><div class="usage"><code>(reorder-columns columns-selector &amp; columns-selectors)</code></div><div class="doc"><div class="markdown"><p>Reorder columns using column selector(s). When column names are incomplete, the missing will be attached at the end.</p></div></div></div><div class="public anchor" id="var-replace-missing"><h3>replace-missing</h3><div class="usage"><code>(replace-missing)</code><code>(replace-missing strategy)</code><code>(replace-missing columns-selector strategy)</code><code>(replace-missing columns-selector strategy value)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-replace-missing-value"><h3>replace-missing-value</h3><div class="usage"><code>(replace-missing-value filter-fn-or-ds scalar-value)</code><code>(replace-missing-value scalar-value)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-right-join"><h3>right-join</h3><div class="usage"><code>(right-join ds-right columns-selector)</code><code>(right-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-row-at"><h3>row-at</h3><div class="usage"><code>(row-at idx)</code></div><div class="doc"><div class="markdown"><p>Get the row at an individual index. If indexes are negative then the dataset  is indexed from the end.</p>
<pre><code class="clojure">user&gt; (ds/row-at stocks 1)
{"date" #object[java.time.LocalDate 0x534cb03b "2000-02-01"],
 "symbol" "MSFT",
 "price" 36.35}
user&gt; (ds/row-at stocks -1)
{"date" #object[java.time.LocalDate 0x6bf60ed5 "2010-03-01"],
 "symbol" "AAPL",
 "price" 223.02}
</code></pre></div></div></div><div class="public anchor" id="var-row-count"><h3>row-count</h3><div class="usage"><code>(row-count)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-row-map"><h3>row-map</h3><div class="usage"><code>(row-map map-fn &amp; [options])</code></div><div class="doc"><div class="markdown"><p>Map a function across the rows of the dataset producing a new dataset  that is merged back into the original potentially replacing existing columns.  Options are passed into the <a href="null">-&gt;dataset</a> function so you can control the resulting  column types by the usual dataset parsing options described there.</p>
<p>Examples:</p>
<pre><code class="clojure">user&gt; (def stocks (ds/-&gt;dataset "test/data/stocks.csv"))
#'user/stocks
user&gt; (ds/head stocks)
test/data/stocks.csv [5 3]:

| symbol |       date | price |
|--------|------------|------:|
|   MSFT | 2000-01-01 | 39.81 |
|   MSFT | 2000-02-01 | 36.35 |
|   MSFT | 2000-03-01 | 43.22 |
|   MSFT | 2000-04-01 | 28.37 |
|   MSFT | 2000-05-01 | 25.45 |
user&gt; (ds/head (ds/row-map stocks (fn [row]
                                    {"symbol" (keyword (row "symbol"))
                                     :price2 (* (row "price")(row "price"))})))
test/data/stocks.csv [5 4]:

| symbol |       date | price |   :price2 |
|--------|------------|------:|----------:|
|  :MSFT | 2000-01-01 | 39.81 | 1584.8361 |
|  :MSFT | 2000-02-01 | 36.35 | 1321.3225 |
|  :MSFT | 2000-03-01 | 43.22 | 1867.9684 |
|  :MSFT | 2000-04-01 | 28.37 |  804.8569 |
|  :MSFT | 2000-05-01 | 25.45 |  647.7025 |
</code></pre></div></div></div><div class="public anchor" id="var-rows"><h3>rows</h3><div class="usage"><code>(rows)</code><code>(rows result-type)</code></div><div class="doc"><div class="markdown"><p>Returns rows of dataset. Result type can be any of: * <code>:as-maps</code> * <code>:as-double-arrays</code> * <code>:as-seqs</code></p></div></div></div><div class="public anchor" id="var-rowvec-at"><h3>rowvec-at</h3><div class="usage"><code>(rowvec-at idx)</code></div><div class="doc"><div class="markdown"><p>Return a persisent-vector-like row at a given index. Negative indexes index  from the end.</p>
<pre><code class="clojure">user&gt; (ds/rowvec-at stocks 1)
["MSFT" #object[java.time.LocalDate 0x5848b8b3 "2000-02-01"] 36.35]
user&gt; (ds/rowvec-at stocks -1)
["AAPL" #object[java.time.LocalDate 0x4b70b0d5 "2010-03-01"] 223.02]
</code></pre></div></div></div><div class="public anchor" id="var-rowvecs"><h3>rowvecs</h3><div class="usage"><code>(rowvecs)</code></div><div class="doc"><div class="markdown"><p>Return a randomly addressable list of rows in persisent vector-like form.</p>
<pre><code class="clojure">user&gt; (take 5 (ds/rowvecs stocks))
(["MSFT" #object[java.time.LocalDate 0x5be9e4c8 "2000-01-01"] 39.81]
 ["MSFT" #object[java.time.LocalDate 0xf758e5 "2000-02-01"] 36.35]
 ["MSFT" #object[java.time.LocalDate 0x752cc84d "2000-03-01"] 43.22]
 ["MSFT" #object[java.time.LocalDate 0x7bad4827 "2000-04-01"] 28.37]
 ["MSFT" #object[java.time.LocalDate 0x3a62c34a "2000-05-01"] 25.45])
</code></pre></div></div></div><div class="public anchor" id="var-sample"><h3>sample</h3><div class="usage"><code>(sample n options)</code><code>(sample n)</code><code>(sample)</code></div><div class="doc"><div class="markdown"><p>Sample n-rows from a dataset. Defaults to sampling <em>without</em> replacement.</p>
<p>For the definition of seed, see the argshuffle documentation](<a href="https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-argshuffle">https://cnuernber.github.io/dtype-next/tech.v3.datatype.argops.html#var-argshuffle</a>)</p>
<p>The returned datasets metadata is altered merging <code>{:print-index-range (range n)}</code> in so you will always see the entire returned dataset. If this isnt desired, <code>vary-meta</code> a good pathway.</p></div></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select columns-selector rows-selector)</code></div><div class="doc"><div class="markdown"><p>Select columns and rows.</p></div></div></div><div class="public anchor" id="var-select-by-index"><h3>select-by-index</h3><div class="usage"><code>(select-by-index col-index row-index)</code></div><div class="doc"><div class="markdown"><p>Trim dataset according to this sequence of indexes. Returns a new dataset.</p>
<p>col-index and row-index - one of:</p>
<ul>
  <li>:all - all the columns</li>
  <li>list of indexes. May contain duplicates. Negative values will be counted from the end of the sequence.</li>
</ul></div></div></div><div class="public anchor" id="var-select-columns"><h3>select-columns</h3><div class="usage"><code>(select-columns)</code><code>(select-columns columns-selector)</code><code>(select-columns columns-selector meta-field)</code></div><div class="doc"><div class="markdown"><p>Select columns by (returns dataset):</p>
<ul>
  <li>name</li>
  <li>sequence of names</li>
  <li>map of names with new names (rename)</li>
  <li>function which filter names (via column metadata)</li>
</ul></div></div></div><div class="public anchor" id="var-select-columns-by-index"><h3>select-columns-by-index</h3><div class="usage"><code>(select-columns-by-index col-index)</code></div><div class="doc"><div class="markdown"><p>Select columns from the dataset by seq of index(includes negative) or :all.</p>
<p>See documentation for <code>select-by-index</code>.</p></div></div></div><div class="public anchor" id="var-select-missing"><h3>select-missing</h3><div class="usage"><code>(select-missing)</code><code>(select-missing columns-selector)</code></div><div class="doc"><div class="markdown"><p>Select rows with missing values</p>
<p><code>columns-selector</code> selects columns to look at missing values</p></div></div></div><div class="public anchor" id="var-select-rows"><h3>select-rows</h3><div class="usage"><code>(select-rows)</code><code>(select-rows rows-selector)</code><code>(select-rows rows-selector options)</code></div><div class="doc"><div class="markdown"><p>Select rows using:</p>
<ul>
  <li>row id</li>
  <li>seq of row ids</li>
  <li>seq of true/false</li>
  <li>fn with predicate</li>
</ul></div></div></div><div class="public anchor" id="var-select-rows-by-index"><h3>select-rows-by-index</h3><div class="usage"><code>(select-rows-by-index row-index)</code></div><div class="doc"><div class="markdown"><p>Select rows from the dataset or column by seq of index(includes negative) or :all.</p>
<p>See documentation for <code>select-by-index</code>.</p></div></div></div><div class="public anchor" id="var-semi-join"><h3>semi-join</h3><div class="usage"><code>(semi-join ds-right columns-selector)</code><code>(semi-join ds-right columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-separate-column"><h3>separate-column</h3><div class="usage"><code>(separate-column column separator)</code><code>(separate-column column target-columns separator)</code><code>(separate-column column target-columns separator options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-set-dataset-name"><h3>set-dataset-name</h3><div class="usage"><code>(set-dataset-name ds-name)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-set-inference-target"><h3>set-inference-target</h3><div class="usage"><code>(set-inference-target target-name-or-target-name-seq)</code></div><div class="doc"><div class="markdown"><p>Set the inference target on the column. This sets the :column-type member of the column metadata to :inference-target?.</p></div></div></div><div class="public anchor" id="var-shape"><h3>shape</h3><div class="usage"><code>(shape)</code></div><div class="doc"><div class="markdown"><p>Returns shape of the dataset [rows, cols]</p></div></div></div><div class="public anchor" id="var-shuffle"><h3>shuffle</h3><div class="usage"><code>(shuffle)</code><code>(shuffle options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-sort-by"><h3>sort-by</h3><div class="usage"><code>(sort-by key-fn compare-fn &amp; [options])</code><code>(sort-by key-fn)</code></div><div class="doc"><div class="markdown"><p>Sort a dataset by a key-fn and compare-fn.</p></div></div></div><div class="public anchor" id="var-sort-by-column"><h3>sort-by-column</h3><div class="usage"><code>(sort-by-column colname compare-fn &amp; [options])</code><code>(sort-by-column colname)</code></div><div class="doc"><div class="markdown"><p>Sort a dataset by a given column using the given compare fn.</p></div></div></div><div class="public anchor" id="var-std-scale"><h3>std-scale</h3><div class="usage"><code>(std-scale col-seq {:keys [mean? stddev?], :or {mean? true, stddev? true}, :as options})</code></div><div class="doc"><div class="markdown"><p>Metamorph transfomer, which centers and scales the dataset per column.</p>
<p><code>col-seq</code> is a sequence of column names to work on</p>
<p><code>options</code> are the options for the scaler and can take:</p>
<p><code>mean?</code> If true (default), the data gets shifted by the column means, so 0 centered</p>
<p><code>stddev?</code> If true (default), the data gets scaled by the standard deviation of the column</p>
<table>
  <thead>
    <tr>
      <th>metamorph </th>
      <th>.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Behaviour in mode :fit </td>
      <td>Centers and scales the dataset at key <code>:metamorph/data</code> and stores the trained model in ctx under key at <code>:metamorph/id</code></td>
    </tr>
    <tr>
      <td>Behaviour in mode :transform </td>
      <td>Reads trained std-scale model from ctx and applies it to data in <code>:metamorph/data</code></td>
    </tr>
    <tr>
      <td>Reads keys from ctx </td>
      <td>In mode <code>:transform</code> : Reads trained model to use for from key in <code>:metamorph/id</code>.</td>
    </tr>
    <tr>
      <td>Writes keys to ctx </td>
      <td>In mode <code>:fit</code> : Stores trained model in key $id</td>
    </tr>
  </tbody>
</table></div></div></div><div class="public anchor" id="var-tail"><h3>tail</h3><div class="usage"><code>(tail)</code><code>(tail n)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-take-nth"><h3>take-nth</h3><div class="usage"><code>(take-nth n-val)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-ungroup"><h3>ungroup</h3><div class="usage"><code>(ungroup)</code><code>(ungroup options)</code></div><div class="doc"><div class="markdown"><p>Concat groups into dataset.</p>
<p>When <code>add-group-as-column</code> or <code>add-group-id-as-column</code> is set to <code>true</code> or name(s), columns with group name(s) or group id is added to the result.</p>
<p>Before joining the groups groups can be sorted by group name.</p></div></div></div><div class="public anchor" id="var-union"><h3>union</h3><div class="usage"><code>(union &amp; datasets)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-unique-by"><h3>unique-by</h3><div class="usage"><code>(unique-by)</code><code>(unique-by columns-selector)</code><code>(unique-by columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-unique-by-column"><h3>unique-by-column</h3><div class="usage"><code>(unique-by-column options colname)</code><code>(unique-by-column colname)</code></div><div class="doc"><div class="markdown"><p>Map-fn function gets passed map for each row, rows are grouped by the return value. Keep-fn is used to decide the index to keep.</p>
<p>:keep-fn - Function from key, idx-seq-&gt;idx. Defaults to #(first %2).</p></div></div></div><div class="public anchor" id="var-unmark-group"><h3>unmark-group</h3><div class="usage"><code>(unmark-group)</code></div><div class="doc"><div class="markdown"><p>Remove grouping tag</p></div></div></div><div class="public anchor" id="var-unordered-select"><h3>unordered-select</h3><div class="usage"><code>(unordered-select colname-seq index-seq)</code></div><div class="doc"><div class="markdown"><p>Perform a selection but use the order of the columns in the existing table; do <em>not</em> reorder the columns based on colname-seq. Useful when doing selection based on sets or persistent hash maps.</p></div></div></div><div class="public anchor" id="var-unroll"><h3>unroll</h3><div class="usage"><code>(unroll columns-selector)</code><code>(unroll columns-selector options)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-unroll-column"><h3>unroll-column</h3><div class="usage"><code>(unroll-column column-name)</code><code>(unroll-column column-name options)</code></div><div class="doc"><div class="markdown"><p>Unroll a column that has some (or all) sequential data as entries.  Returns a new dataset with same columns but with other columns duplicated  where the unroll happened. Column now contains only scalar data.</p>
<p>Any missing indexes are dropped.</p>
<pre><code class="clojure">user&gt; (-&gt; (ds/-&gt;dataset [{:a 1 :b [2 3]}
                              {:a 2 :b [4 5]}
                              {:a 3 :b :a}])
               (ds/unroll-column :b {:indexes? true}))
  _unnamed [5 3]:

| :a | :b | :indexes |
|----+----+----------|
|  1 |  2 |        0 |
|  1 |  3 |        1 |
|  2 |  4 |        0 |
|  2 |  5 |        1 |
|  3 | :a |        0 |
</code></pre>
<p>Options -  :datatype - datatype of the resulting column if one aside from :object is desired.  :indexes? - If true, create a new column that records the indexes of the values from  the original column. Can also be a truthy value (like a keyword) and the column  will be named this.</p></div></div></div><div class="public anchor" id="var-update"><h3>update</h3><div class="usage"><code>(update filter-fn-or-ds update-fn &amp; args)</code></div><div class="doc"><div class="markdown"><p>Update this dataset. Filters this dataset into a new dataset,  applies update-fn, then merges the result into original dataset.</p>
<p>This pathways is designed to work with the tech.v3.dataset.column-filters namespace.</p>
<ul>
  <li><code>filter-fn-or-ds</code> is a generalized parameter. May be a function,  a dataset or a sequence of column names.</li>
  <li>update-fn must take the dataset as the first argument and must return  a dataset.</li>
</ul>
<pre><code class="clojure">(ds/bind-&gt; (ds/-&gt;dataset dataset) ds
           (ds/remove-column "Id")
           (ds/update cf/string ds/replace-missing-value "NA")
           (ds/update-elemwise cf/string #(get {"" "NA"} % %))
           (ds/update cf/numeric ds/replace-missing-value 0)
           (ds/update cf/boolean ds/replace-missing-value false)
           (ds/update-columnwise (cf/union (cf/numeric ds) (cf/boolean ds))
                                 #(dtype/elemwise-cast % :float64)))
</code></pre></div></div></div><div class="public anchor" id="var-update-column"><h3>update-column</h3><div class="usage"><code>(update-column col-name update-fn)</code></div><div class="doc"><div class="markdown"><p>Update a column returning a new dataset. update-fn is a column-&gt;column transformation. Error if column does not exist.</p></div></div></div><div class="public anchor" id="var-update-columns"><h3>update-columns</h3><div class="usage"><code>(update-columns columns-map)</code><code>(update-columns columns-selector update-functions)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-update-columnwise"><h3>update-columnwise</h3><div class="usage"><code>(update-columnwise filter-fn-or-ds cwise-update-fn &amp; args)</code></div><div class="doc"><div class="markdown"><p>Call update-fn on each column of the dataset. Returns the dataset. See arguments to update</p></div></div></div><div class="public anchor" id="var-update-elemwise"><h3>update-elemwise</h3><div class="usage"><code>(update-elemwise filter-fn-or-ds map-fn)</code><code>(update-elemwise map-fn)</code></div><div class="doc"><div class="markdown"><p>Replace all elements in selected columns by calling selected function on each element. column-name-seq must be a sequence of column names if provided. filter-fn-or-ds has same rules as update. Implicitly clears the missing set so function must deal with type-specific missing values correctly. Returns new dataset</p></div></div></div><div class="public anchor" id="var-value-reader"><h3>value-reader</h3><div class="usage"><code>(value-reader)</code></div><div class="doc"><div class="markdown"><p>Return a reader that produces a reader of column values per index. Options: :missing-nil? - Default to true - Substitute nil in for missing values to make  missing value detection downstream to be column datatype independent.</p></div></div></div><div class="public anchor" id="var-write.21"><h3>write!</h3><div class="usage"><code>(write! output-path options)</code><code>(write! output-path)</code></div><div class="doc"><div class="markdown"><p>Write a dataset out to a file. Supported forms are:</p>
<pre><code class="clojure">(ds/write! test-ds "test.csv")
(ds/write! test-ds "test.tsv")
(ds/write! test-ds "test.tsv.gz")
(ds/write! test-ds "test.nippy")
(ds/write! test-ds out-stream)
</code></pre>
<p>Options:</p>
<ul>
  <li><code>:max-chars-per-column</code> - csv,tsv specific, defaults to 65536 - values longer than this will  cause an exception during serialization.</li>
  <li><code>:max-num-columns</code> - csv,tsv specific, defaults to 8192 - If the dataset has more than this number of  columns an exception will be thrown during serialization.</li>
  <li><code>:quoted-columns</code> - csv specific - sequence of columns names that you would like to always have quoted.</li>
  <li><code>:file-type</code> - Manually specify the file type. This is usually inferred from the filename but if you  pass in an output stream then you will need to specify the file type.</li>
  <li><code>:headers?</code> - if csv headers are written, defaults to true.</li>
</ul></div></div></div><div class="public anchor" id="var-write-nippy.21"><h3>write-nippy!</h3><div class="usage"><code>(write-nippy! filename)</code></div><div class="doc"><div class="markdown"></div></div></div></div></body></html>